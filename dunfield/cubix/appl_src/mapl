	title	MICRO APL 1.0
*
* MICRO-APL 1.0
*
* Simple APL SUBSET for the 6809, using the standard ASCII
* character set. Lower case characters are used instead of
* special APL characters to represent some of the primitive
* functions. The function of the "SHIFT" key is reversed to
* allow easier operation (SHIFT = special functions)
*
* SYSTEM COMMANDS:
*
*  )OFF, )LIB, )SI, )REL, )RESET, )LOAD, )SAVE, )WSID, )DROP,
*  )CLEAR, )SYS, )VARS, )FNS, )LBLS, )STAT
*
* MONADIC (SINGLE OPERAND) OPERATORS:
*
*  i - INDEX VECTOR GENERATION		 p - SHAPE OF OPERAND
*  r - REVERSE OPERAND			 c - CLASSIFICATION
*  e - EXECUTE STRING OPERAND		 s - CONVERT TO STRING
*  ? - ROLL RANDOM VECTOR		 ^ - SORT VECTOR
*  b - BRANCH TO LABEL
*
* DYADIC (TWO OPERAND) OPERATORS:
*
*  + - ADDITION				 - - SUBTRACTION
*  x - MULTIPLICATION			 % - DIVISION
*  m - MODULUS				 & - LOGICAL AND
*  ! - LOGICAL OR			 | - EXCLUSIVE OR
*  g - GREATEST				 l - LEAST
* == - TEST FOR EQUALITY		-= - TEST FOR INEQUALITY
*  > - TEST FOR GREATER THAN		 < - TEST FOR LESS THAN
* >= - TEST FOR GREATOR OR EQUAL	<= - TEST FOR LESS OR EQUAL
*  = - ASSIGNMENT			 / - EXTRACTION
*  ; - JOIN				 t - TAKE
*  d - DROP				 f - FIND
*  | - EXCLUSIVE OR			 u - UNION OF SETS
*  n - TRANSLATE
*
* OTHER OPERATORS:
*
* [] - INDEX ACCESS			() - NEST
*  \ - TRAVEL				 $ - FUNCTION DEFINITION
*
* SYSTEM VARIABLES:
*
*  B$ - BUFFER SIZE			C$ - CHARACTER VECTOR
*  F$ - FORMATTED I/O			K$ - READ KEYSTROKE
*  L$ - LINE NUMBER			O$ - ORIGIN VALUE
*  P$ - PARAMETER			R$ - REMAINDER
*  S$ - RANDOM SEED			T$ - TERMINAL I/O
*  W$ - AVAILABEL WORKSPACE
*
* Copyright 1984,1990 Dave Dunfield
* All rights reserved.
*
* DATA AREAS
*
ROM	EQU	OSRAM		PROGRAMM GOES HERE
RAM	EQU	OSRAM+7168	DATA GOES HERE
HIRAM	EQU	OSUTIL-1024	TOP OF RAM
*
LEVEL	EQU	RAM+130
EXEC	EQU	LEVEL+1
TEMP	EQU	EXEC+1
TEMP0	EQU	TEMP+2
TEMP1	EQU	TEMP0+2
TEMP2	EQU	TEMP1+2
TEMP3	EQU	TEMP2+2
TEMP4	EQU	TEMP3+2
TEMP5	EQU	TEMP4+2
TXTTMP	EQU	TEMP5+2
PARM	EQU	TXTTMP+2
LINCT	EQU	PARM+2
GOTO	EQU	LINCT+2
NAMPTR	EQU	GOTO+2
DIVREM	EQU	NAMPTR+2
TXTPTR	EQU	DIVREM+2
SAVSTK	EQU	TXTPTR+2
RAMTOP	EQU	SAVSTK+2
ASSFLG	EQU	RAMTOP+2
ERRFLG	EQU	ASSFLG+1
INPSTK	EQU	ERRFLG+1
ID	EQU	INPSTK+2
STACK	EQU	RAM+1024
* WORKSPACE CONTENTS
FREE	EQU	RAM+1024
ORIGIN	EQU	FREE+2
SEED	EQU	ORIGIN+2
BUFSIZ	EQU	SEED+2
FREMEM	EQU	BUFSIZ+2
SYMTAB	EQU	FREMEM+2
*
	ORG	ROM
* PROGRAM ENTRY
APL	LBSR	SYSMSG
	FCCZ	'MAPL version 1.0'
	CLRA			INDICATE ERR MSGS
	SSR	105		TURN OFF ERROR MESSAGES
	LDY	#CONTIN		POINT TO CONTINUE NAME
	SSR	10		GET NAME
	LEAY	8,X		POINT TO IT
	SSR	68		DOES IT EXIST?
	LBEQ	LDGO		IF SO, LOAD IT
	BRA	DEFCLR		DEFAULT CLEAR
* ')CLEAR' COMMAND
CLEAR	LBSR	SKIP		LOOK FOR PARAMETER
	BEQ	DEFCLR		ASSUME DEFAULT
CLER1	LDA	,Y+		GET CHAR
	CMPA	#$0D		CONTINUE
	BNE	CLER1		TO END OF LINE
	LEAY	-1,Y		BACKUP TO CR
	LBSR	SKBK		BACKUP TO NUMBER
	LBSR	VALNUM		VALID DIGIT?
	LBNE	UNCMD		INVALID
	LBSR	GETDEC		GET DECIMAL
	BRA	CLRGO		CONTINUE
DEFCLR	LDD	#1000		DEFAULT SYMBNOL TABLE SIZE
CLRGO	ADDD	#SYMTAB+1	OFFSET FOR SYMBOL TABLE ADDRESS
	STD	FREMEM		POINT TO FREE MEMORY
	STD	>FREE		INDICATE HOW MUCH IS FREE
	CLR	>SYMTAB		REMOVE SYMBOLS
	LDD	#1024		DEFAULT BUFER SIZE
	STD	BUFSIZ		SAVE BUFFER SIZE
	LDY	#CID		POINT TO NEW ID
	LBSR	WSISET		SET UP WSID
	LDD	#1		GET A 1 ORIGIN
	STD	ORIGIN		SAVE ORIGIN VALUE
	COMA			GARBAGE VALUE
	STD	SEED		SET UP SEED
CLMSG	LBSR	SYSMSG		DISPLAY MESSAGE
CID	FCCZ	'CLEAR WS'
	LDS	#STACK		POINT TO SYSTEM STACK
	STS	SAVSTK		INTIALIZE IT
* ')RESET' SYSTEM COMMAND
RESET	LBSR	DOREST		DO A RESET
* COMMAND INTERPRETER
CMD	BSR	INIWS		INIT WORKSPACE PARMS
	LDS	SAVSTK		SET UP STACK
	LBSR	DSPSTR		DISPLAY MESSAGE
	FCCZ	'      '	SPACE OVER
	LBSR	GETRAM		GET A LINE OF INPUT
	LBSR	SKIP		SKIP TO COMMAND
	BEQ	CMD		IF NONE, TRY AGAIN
	CMPA	#'*'		COMMENT?
	BEQ	CMD		IF SO, GO FOR IT
	CMPA	#')'		SYSTEM COMMAND?
	LBNE	EDIT		NO, PROCESS EXPRESSION
	LDX	#CMDTAB		POINT TO COMMAND TABLE
	LBSR	CLOOK		LOOK UP AND EXECUTE COMMAND
	BRA	CMD		GET NEXT
INIWS	CLR	EXEC		INSURE NOTHING RUNNING
	LDD	#0
	STD	INPSTK		SAVE INPUT STACK POINTER
	LDD	RAMTOP		GET TOP OF RAM
	STD	TEMP5		SAVE FREE MEMORY INDICATOR
	RTS
* ')LOAD' COMMAND
LOAD	LBSR	FILNAM		GET FILENAME
	SSR	10		TELL DOS
	LBNE	UNCMD		GET UPSET IF BAD
	LEAY	8,X		POINT TO NAME
LDGO	LDX	#FREE		POINT TO FREE SPACE
	SSR	53		LOAD FILE
	BEQ	LOA2		IT'S OK, CONTINUE
LOA1	LBSR	SYSMSG		INDICATE SYSTEM ERROR
	FCCZ	'WS NOT FOUND'
	RTS
* PERFORM INIT
LOA2	LBSR	WSISET		SET NAME
	LBSR	DOREST		PERFORM RESET
	BSR	INIWS		INIT WORKSPACE
	LDS	SAVSTK		SET UP STACK
	LBSR	DSPSTR		DISPLAY STRING
	FCCZ	'WSID IS '	MESSAGE TO DISPLAY
	LBSR	DWSID		DISPLAY
	LDY	#LXNAME		POINT TO LATENT EXPRESSION
	LBSR	LOOKUP		IS IT FOUND?
	BNE	CMD1		NO, SKIP IT
PROCMD	LBSR	EXPR		EVALUATE EXPRESSION
CMD1	LBRA	CMD		PERFORM COMMAND
* ')DROP' COMMAND
DROP	LBSR	FILNAM		GET FILENAME
	SSR	10		TELL DOS
	LBNE	UNCMD		GET UPSET IF INVALID
	SSR	73		THROW IT AWAY
	BNE	LOA1		IF NOT FOUND
	RTS
*
* FUNCTION EDITOR
*
EDIT	CMPA	#'$'		CREATE A FUNCTION?
	LBNE	PROCMD		PROCESS COMMAND
	STY	TEMP		SAVE POINTER
	LBSR	SFSYM		SKIP FORWARD
	BNE	NAMOK		NAME IS OK
DEFERR	LBSR	SYSMSG		DISPLAY MESSAGE,
	FCCZ	'DEFN ERROR'
	LBRA	CMD		AND BACK FOR COMMAND
NAMOK	STY	TEMP3		SAVE Y REG
	LBSR	DOREST		PERFORM A RESET
	LDY	TEMP3		RESTORE
	LEAY	-1,Y		BACKUP TO FIRST CHAR OF SYMBOL
	CLRA
	CLRB			GET A ZERO
	STD	TEMP3		INITIALIZE LINE NUMBER
	LBSR	LOOKUP		LOOK FOR ENTRY
	BEQ	FUNFND		FUNCTION EXISTS
	LDY	TEMP		POINT TO NAME
	LBSR	SKP		ADVANCE TO NEXT CRAP
	LDX	FREE		POINT TO FREE RAM
	CLR	,X+		RESAVE
	STX	TEMP2		SAVE POINTER TO FUNCTION BEING EDITED
CRED1	LDA	,Y+		GET CHAR
	STA	,X+		SAVE
	CMPA	#$0D		END?
	BNE	CRED1		NO, CONTINUE
	LDA	#$FF		GET END OF FUNCTION INDICATOR
	STA	,X+		SAVE IN RAM
	INC	TEMP3+1		START ON LINE 1
	BRA	EDTRUN		EDIT THE FUNCTION
* FUNCTION EXISTED, COPY IT OVER
FUNFND	STX	TEMP		SAVE POINTER TO SYMBOL TABLE ENTRY
	TSTA			IS IT AN UNLOCKED FUNCTION?
	BNE	DEFERR		CAN'T EDIT UNLESS IT'S A FUNCTION
	LDY	B,X		GET POINTER TO FUNCTION ADDRESS
	LDX	FREE		POINT TO AVAILABEL MEMORY
	CLR	,X+		CLEAR BYTE FOR FUNCTION
	STX	TEMP2		RESAVE
* INSERT NAME AS LINE #0
	LDU	TEMP		POINT TO SYMBOL TABLE ENTRY AGAIN
	LDB	,U++		GET LENGTH
	ANDB	#$1F		MASK LENGTH
	LEAU	B,U		INDICATE THIS IS IT
EDX1	LDA	,-U		GET CHARACTER
	STA	,X+		SAVE IN NAME
	DECB			REDUCE COUNT
	BNE	EDX1		AND KEEP DOING IT
CPYFUN	LDA	,Y+		GET CHARACTER FROM FUNCTION
	STA	,X+		SAVE IN WORKSPACE BUFFER
	CMPA	#$0D		END OF LINE?
	BNE	CPYF1		NO, ADVANCE TO NEXT
	INC	TEMP3+1		ADVANCE LINE NUMBER
	BCC	CPYF1		AND SKIP IF NO CARRY
	INC	TEMP3		ADVANCE HIGH DIGIT
CPYF1	CMPA	#$FF		END OF FUNCTION?
	BNE	CPYFUN		CONTINUE TILL WE COPY IT ALL
* START UP THE EDITOR
EDTRUN	LEAX	-1,X		BACKUP TO END OF FILE MARKER
EDTLIN	LDA	#'['		GET STARTING BRACE
	LBSR	PUTCHR		DISPLAY
	LDD	TEMP3		GET LINE NUMBER
	LBSR	DECOUT		DISPLAY
	LDA	#']'		GET POINTER
	LBSR	PUTCHR		DISPLAY
	LBSR	SPACE		AND A BLANK
	LBSR	GETRAM		GET A LINE
	LBSR	SKP		IS IT COMMAND
	BEQ	EDTLIN		BAD, TRY AGAIN
	CMPA	#'$'		END OF DEFINITION
	LBEQ	RESAVE		RESAVE EDITED FUNCTION
	CMPA	#'['		IS IT COMMAND?
	BEQ	EDCMD		EXECUTE EDIT COMMAND
	LBSR	DELETE		DELETE THIS LINE
	LBSR	INSERT		INSERT THIS LINE
INCLIN	INC	TEMP3+1		ADVANCE LINE NUMBER
	BCC	EDTLIN		IF NO CARRY, EVERYTHING OK
	INC	TEMP3		AND GO FOR BROKE
	BRA	EDTLIN		EDIT LINE
ERRDEF	PSHS	X		SAVE POINTER
	LBSR	SYSMSG		DISPLAY MESSAGE
	FCCZ	'DEFN ERROR'
	PULS	X		RESTORE
	BRA	EDTLIN		BACK TO LINE
*
* EDITOR COMMAND
*
EDCMD	LEAY	1,Y		SKIP '['
	LBSR	SKIP		ADVANCE TO NEXT
	CMPA	#'$'		IS IT DISPLAY
	BNE	EDC1		NOT A QUAD
	LBSR	SFNUM		LOOK FOR NUMBER
	BEQ	EDC2		SHOW ALL
	LBSR	GETDIG		GET NUMBER
	BRA	EDC3		IT'S OK
EDC2	LBSR	DSPSTR		DISPLAY MSG
	FCCZ	'     $'	DISPLAY
	LDX	TEMP2		POINT TO SPACE
	LBSR	OULI		DISPLAY
	LDD	#1		DISPLAY LINE 1
EDC3	LBSR	FNDLIN		POINT TO LINE
DISP	LDA	,X		ARE WE AT END
	CMPA	#$FF		TEST FOR END OF FILE
	BEQ	EDC5		QUIT IF END
	LBSR	DSPLIN		DISPLAY A LINE
	LDD	TEMP3		GET NUMBER
	ADDD	#1		ADVANCE
	STD	TEMP3		AND RESAVE
	BRA	DISP		AND CONTINUE
* DELETE LINES
EDC1	CMPA	#'D'		IS IT DELETE LINE?
	BNE	EDC4		NO, TRY POSITION
	LBSR	SFNUM		LOOK FOR LINE NUMBER
	BEQ	ERRDEF		CAN'T DELETE
	LBSR	GETDIG		GET NUMBER
	CMPD	#0		TRYING TO DELETE 0?
	BEQ	ERRDEF		INVALID
	LBSR	FNDLIN		LOCATE LINE
	LBSR	DELETE		GET RID OF IT
EDC5	LBRA	EDTLIN		NEXT COMMAND
* INSERT LINE(S)
EDC4	CMPA	#'I'		INSERT?
	BNE	EDCP		NO, FORGET IT
	LBSR	SFNUM		ARE WE OK?
	LBEQ	ERRDEF		NO, NO NUMBER
	LBSR	GETDIG		GET THE NUMBER
	CMPD	#0		CANNOT INSERT IN LINE 0
	LBEQ	ERRDEF		SAY SO
	LBSR	FNDLIN		LOCATE THE LINE
EDCZ	LDA	#'('		DISPLAY MESSAGE
	LBSR	PUTCHR		OUTPUT
	LDD	TEMP3		GET LINE NUMBER
	LBSR	DECOUT		OUTPUT
	LDA	#')'		CLOSING PROMPT
	LBSR	PUTCHR		DISPLAY
	LBSR	SPACE		SPACE OVER
	LBSR	GETRAM		GET A LINE
	LBSR	SKP		IS IT THE END
	BEQ	EDCX		IF SO, QUIT
	LBSR	INSERT		PUT IT HERE
	LDD	TEMP3		GET LINE NUMBER
	ADDD	#1		ADVANCE
	STD	TEMP3		AND GO AGAIN
	BRA	EDCZ		AND GET NEXT LINE
EDCX	LBRA	EDTLIN		BACK FOR NEXT COMMAND
* POSITION TO LINE
EDCP	LBSR	VALNUM		IS IT VALID?
	LBNE	ERRDEF		NO, GET UPSET
	LEAY	-1,Y		BACKUP TO IT
	LBSR	SFNUM		LOOK FOR NUMBER
	PSHS	A		SAVE CHARACTER
	LBSR	GETDIG		GET NUMBER
	LBSR	FNDLIN		LOCATE IT
	PULS	A		GET CHARACTER BACK
	CMPA	#'$'		DO WE DISPLAY?
	BNE	EDCX		NO, JUST GO THERE
	PSHS	X		SAVE POSITION
	LBSR	DSPLIN		DISPLAY
	PULS	X		RESTORE X
	LBRA	EDTLIN		AND GO HOME
* SAVE NEW FUNCTION DEFINITION, INSERT AT BEGINNING OF SYMBOL TABLE
RESAVE	LDA	1,Y		GET NEXT CHARACTER
	STA	ASSFLG		SAVE
	CLRA
	CLRB			GET A ZERO
	STD	TEMP3		SET LINE NUMBER
	LDX	TEMP2		POINT TO START
	TFR	X,Y		COPY IT
	LBSR	SFSYM		SKIP TO END
	LBEQ	ERRDEF		INVALID DEFN
	STB	TEMP4		SAVE LENGTH
	STY	TEMP3		SAVE POINTER TO SYMBOL
	LEAY	-1,Y		BACKUP
	LBSR	LOOKUP		LOOK FOR IT
	BNE	NOER1		DON'T ERASE
	LBSR	ERASYM		ERASE IT
NOER1	LDX	TEMP3		POINT TO WORKSPACE
RE2	LDA	,X+		GET SYMBOL CHAR
	CMPA	#$FF		END OF PROGRAM?
	BNE	RE2		NO
	TFR	X,D		COPY
	SUBD	TEMP3		CONVERT TO OFFSET VALUE
	STD	TEMP1		SAVE OFFSET VALUE
* RIFLE THROUGH SYMBOL TABLE, LOOKING FOR END, AND ADDING OFFSET TO THE
* EXISTING SYMBOLS
	LDX	#SYMTAB-2	POINT TO SYMBOL TABLE
RIF0	LEAX	2,X		ADVANCE
RIF1	LDB	,X++		GET OFFSET
	TFR	B,A		COPY TO A
	ANDA	#$E0		MASK LENGTH
	ANDB	#$1F		MASK TYPE
	BEQ	RIF2		HIT THE END
	LEAX	B,X		OFFSET TO DATA AREA
	CMPA	#$60		IS IT LABEL TYPE
	BEQ	RIF0		IF SO, DON'T ADJUST
	LDD	,X		GET ADDRESS
	ADDD	TEMP1		ADD OFFSET
	STD	,X++		RESAVE
	BRA	RIF1		AND CONTINUE
* ADVANCE SYMBOL TABLE ENOUGH FOR ENTRY
RIF2	LDB	TEMP4		GET LENGTH
	ADDB	#4		ADD TYPE/ADDRESS BYTES
	LEAY	B,X		POINT TO ABOVE ADDRESS
RIF3	LDA	,-X		GET BYTE FROM TABLE
	STA	,-Y		SAVE IN NEW LOCATION
	CMPX	#SYMTAB		ARE WE PAST BEGINNING?
	BHI	RIF3		NO, KEEP GOING
* CREATE SYMBOL TABLE ENTRY
	LDB	TEMP4		GET LENGTH
	LDA	ASSFLG		RESTORE TYPE
	CMPA	#'$'		IS IT LOCK?
	BNE	NOLOKI		DON'T LOCK
	ORB	#$20		SET TYPE TO ONE
NOLOKI	STB	,X+		SAVE LENGTH IN TABLE
	CLR	,X+		AND SET NEST BYTE
	LDY	TEMP3		POINT TO ENTRY
	ANDB	#$1F		REMOVE TYPE INFO
RIF4	LDA	,-Y		GET CHARACTER
	STA	,X+		SAVE IN TABLE
	DECB			REDUCE COUNT
	BNE	RIF4		CONTINUE
	LDD	FREMEM		POINT TO FREE MEMORY
	STD	,X		SET ADDRESS
* MOVE MEMORY AHEAD, TO MAKE ROOM
	LDX	TEMP3		GET PROGRAM ADDRESS
	LDD	TEMP1		GET SIZE
	LEAY	D,X		ADVANCE TO END OF PROGRAM
	PSHS	Y		SAVE POINTER
	LEAX	D,Y		ADVANCE TO EXTRA SPACE FOR COPY
RIF5	LDA	,-Y		GET BYTE
	STA	,-X		SAVE IN NEW LOCATION
	CMPY	FREMEM		HIT THE BEGINNING?
	BHI	RIF5		NO, KEEP GOING
	PULS	X		RESTORE POINTER TO TEXT
RIF6	LDA	,X+		GET FROM PROGRAM
	STA	,Y+		SAVE
	CMPA	#$FF		AT THE END?
	BNE	RIF6		NO, SKIP IT
	LDD	FREE		GET FREE MEMORY
	ADDD	TEMP1		ADD IN PROGRAM SIZE
	STD	FREE		RESAVE
	LBRA	CMD		GET NEXT COMMAND
*
* EDITOR SUBROUTINES
*
* DISPLAY LINE (X)
DSPLIN	LDA	#'['		GET OPANING BRACE
	LBSR	PUTCHR		OUTPUT
	LDD	TEMP3		GET LINE NUMBER
	LBSR	DECOUT		DISPLAY
	LDA	#']'		CLOSING BRACE
	LBSR	PUTCHR		DISPLAY
	LBSR	SPACE		DISPLAY A SPACE
	PSHS	X,Y		SAVE POINTER
	TFR	X,Y		COPY IT OVER
	LBSR	SFSYM		LOOK FOR SYMBOL
	BEQ	EXTSPC		IF NONE, EXTRA SPACE
	CMPA	#':'		WAS IT A LABEL?
	BEQ	NOESPC		YES, OUTDENT IT ONE COLUMN
EXTSPC	LBSR	SPACE		DISPLAY
NOESPC	PULS	X,Y		RESTORE REGS
* DISPLAY MESSAGE (X)
OULI	LDA	,X+		GET CHARACTER FROM LINE
	BEQ	OULX		IF ZERO, TERMINATE
	LBSR	PUTCHR		DISPLAY
	CMPA	#$0A		END OF LINE?
	BNE	OULI		NO, CONTINUE
OULX	RTS
* MOVE TO AND FIND LINE INDICATED BY D
FNDLIN	LDX	TEMP2		POINT TO TEXT
FNDL1	PSHS	A,B,Y		SAVE INDICATORS
	CLRA
	CLRB			START WITH ZERO
FND1	LDY	,S		GET VALUE
	BEQ	FND4		LINE IS FOUND
	LEAY	-1,Y		DECREMENT
	STY	,S		AND RESAVE
	ADDD	#1		INCREMENT LINE NUMBER
	PSHS	A		SAVE CHARACTER
FND2	LDA	,X+		ADVANCE
	CMPA	#$FF		IS IT END OF FILE?
	BEQ	FND3		IF SO, QUIT
	CMPA	#$0D		END OF LINE
	BNE	FND2		GIVE UP
	PULS	A		RESTORE CHARACTER
	BRA	FND1		AND KEEP LOOKING
FND3	PULS	A		RESTORE CHARACTER
	LEAX	-1,X		BACKUP TO VALUE
FND4	STD	TEMP3		SAVE NUMBER
	PULS	A,B,Y,PC	GO HOME
* DELETE LINE POINTED TO BY X
DELETE	PSHS	X,Y		SAVE POINTERS
	TFR	X,Y		COPY TO Y REGISTER
DEL1	LDA	,X+		GET CHARACTER FROM LINE
	CMPA	#$FF		END OF LINE
	BEQ	DEL3		IF SO, QUIT
	CMPA	#$0D		END OF LINE?
	BNE	DEL1		NO, KEEP LOOKING
DEL2	LDA	,X+		GET CHARACTER FROM TEXT
	STA	,Y+		SAVE IN OLD POSITION
	CMPA	#$FF		END OF TEXT?
	BNE	DEL2		NO, KEEP GOING
DEL3	PULS	X,Y,PC		GO HOME
*
* FIND END OF FILE
*
FNDEOF	LDA	,X+		GET CHARACTER FROM FILE
	CMPA	#$FF		ARE WE AT END?
	BNE	FNDEOF		NO, KEEP LOOKING\
	RTS
*
* INSERT LINE INTO TEXT
*
INSERT	PSHS	X,Y		SAVE POINTERS
	CLRB			CLEAR LENGTH
INS1	INCB			ADVANCE COUNT
	LDA	,Y+		LOOK FOR END OF LINE
	CMPA	#$0D		END OF LINE?
	BNE	INS1		NO, SKIP IT
	BSR	FNDEOF		FIND END OF FILE
	LEAY	B,X		ADVANCE TO NEXT
INS2	LDA	,-X		GET CHARACTER FROM TEXT
	STA	,-Y		AND SAVE AT NEW POSITION
	CMPX	,S		ARE WE BACK TO NEW POSITION
	BHI	INS2		KEEP GOING TILL WE GET TO END
	PULS	X,Y		GET POINTERS BACK
INS3	LDA	,Y+		GET CHARACTER FROM BUFFER
	STA	,X+		SAVE IN TEXT
	DECB			REDUCE COUNT
	BNE	INS3		AND KEEP COPYING
	RTS
*
* SYSTEM SUBROUTINES
*
* GET A LINE OF INPUT
*
GETRAM	LDY	#RAM		POINT TO RAM
	BRA	GETLIN		GET INPUT LINE
GETLF	LBSR	LFCR		NEW LINE
GETLIN	LDA	#$0D		GET CR
	STA	,Y+		SABE IN RAM LOCATION
	CLRB			INDICATE AT POSITION ZERO
GET1	TSTB			TEST FOR OVER LIMIT
	BMI	GETLF		IF SO, TRY AGAIN
	BSR	GETCHR		GET INPUT CHARACTER
	CMPA	#$03		CONTROL-C
	BEQ	INPBRK		IF SO, INTERRUPT
	CMPA	#$7F		DELETE?
	BEQ	DELCHR		IF SO, DELETE IT
	STA	B,Y		SAVE IN BUFFER
	INCB			ADVANCE TO NEXT
	LBSR	PUTCHR		DISPLAY
	CMPA	#$0A		CARRIAGE RETURN?
	BNE	GET1		NO, SKIP IT
	RTS
DELCHR	DECB			BACKUP OVER CHARACTER
	PSHS	X		SAVE POINTER
	LBSR	DSPSTR		DISPLAY
	FCB	$08,$20,$08,0	MESSAGE TO DELETE
	PULS	X		RESTORE
	BRA	GET1		AND GO AGAIN
INPBRK	LDA	#$0D		GET CR
	STA	B,Y		SAVE IT
	LEAY	-1,Y		BACKUP TO BEFORE CR
	LBSR	PUTCHR		DISPLAY NEW LINE
	LBRA	BREAK		PERFORM BREAK
* READ A CHARACTER
GETCHR	SSR	34		GET A CHARACTER
	CMPA	#$41		<'A'?
	BLO	CHROK		IF SO, IT'S OK
	CMPA	#$5A		>'Z'?
	BHI	NOC1		NO CONVERSION
	ORA	#$20		CONVERT TO LOWER CASE
CHROK	RTS
NOC1	CMPA	#$61		<'A' (LOWER)?
	BLO	CHROK		IT'S OK
	CMPA	#$7A		>'Z' (LOWER)?
	BHI	CHROK		IF SO, IT'S OK
	ANDA	#$5F		CONVERT TO UPPER CASE
	RTS
*
* DISPLAY STRING
*
DSPSTR	PULS	X		GET POINTER TO MESSAGE
DSP1	LDA	,X+		GET FROM TEXT
	BEQ	DSP2		QUIT
	BSR	PUTCHR		DISPLAY
	BRA	DSP1		AGAIN
DSP2	TFR	X,PC		RETURN
*
* DISPLAY SYSTEM MESSAGE
*
SYSMSG	PULS	X		GET X FROM PC
SY1	LDA	,X+		GET CHAR
	BEQ	ENM1		END OF MESSAGE
	BSR	PUTCHR		OUTPUT
	BRA	SY1		AND DISPLAY
ENM1	PSHS	X		SAVE PC AGAIN
* DISPLAY LFCR ON TERMINAL
LFCR	LDA	#$0D		NEW LINE
	BSR	PUTOUT		DISPLAY
	LDA	#$0A		LF
* DISPLAY A CHARACTER
PUTCHR	CMPA	#$0D		END OF LINE?
	BEQ	LFCR		IF SO, DISPLAY LFCR
PUTOUT	SSR	33		DISPLAY
	RTS
* DISPLAY A SPACE
SPACE	LDA	#' '		GET A SPACE
	BRA	PUTCHR		AND DISPLAY
* SKIP WITHOUT ADVANCING
SKP	LDA	,Y+		GET CHR
	CMPA	#' '		TEST FOR BLANK
	BEQ	SKP		AND FIND A NON-BLANK
	LEAY	-1,Y		BACKUP TO IT
	CMPA	#$0D		TEST FOR END OF LINE
	RTS
* SKIP TO NEXT NON-BLANK
SKIP	LDA	,Y+		GET CHARACTER
	CMPA	#' '		BLANK?
	BEQ	SKIP		TRY AGAIN
	CMPA	#$0D		CR?
	BNE	OKRTS		SKIP IT
	LEAY	-1,Y		BACKUP
	ORCC	#4		SET Z FLAG
OKRTS	RTS
* SKIP BACK BUT CHECK HERE FIRST
SKBKP	LEAY	1,Y		ADVANCE FIRST
* SKIP BACKWARD TO NEXT NON-BLANK
SKBK	LDA	,-Y		BACKUP
	CMPA	#' '		SPACE?
	BEQ	SKBK		CONTINUE
	CMPA	#$0D		START OF LINE?
	RTS
* SKIP FORWARD THROUGH A NUMBER
SFNUM	LDB	#-1		START WITH MINUS ONE
SFN1	INCB			ADVANCE FOR LENGTH
	LDA	,Y+		ADVANCE
	BSR	VALNUM		IS IT A VALID DIGIT?
	BEQ	SFN1		IF SO, CONTINUE
	LEAY	-1,Y		BACKUP TO START OF NUMBER
	TSTB			CHECK FOR ZERO LENGTH
	RTS
* SKIP FORWARD THROUGH A VARIABLE
SFSYM	LDB	#-1		START WITH MINUS ONE
SFS1	INCB			ADVANCE FOR LENGTH
	LDA	,Y+		ADVANCE
	BSR	VALSYM		IS IT VALID?
	BEQ	SFS1		AND CONTINUE
	LEAY	-1,Y		BACKUP
	TSTB			TEST FOR ZERO LENGTH
	RTS
* SET Z FLAG IF PASSED CHARACTER IS A VALID NUMBER
VALNUM	CMPA	#'0'		IN RANGE?
	BLO	BADSYM		NO, IT'S BAD
	CMPA	#'9'		IN RANGE?
	BHI	BADSYM		NO, IT'S BAD
	BRA	VALOK		VALUE IS OK
* SET Z FLAG IS PASSED CHARACTER IS A VALID SYMBOL
VALSYM	CMPA	#'@'		IN RANGE?
	BLO	BADSYM		NO, IT'S BAD
	CMPA	#'Z'		IN RANGE?
	BHI	BADSYM		NO, IT'S BAD
VALOK	ORCC	#4		INDICATE OK
BADSYM	RTS
*
* GETS NUMERIC VALUE FROM LINE(Y)., RETURNS IN D
*
GETDEC	LEAY	1,Y		ADVANCE
GETDIG	LDD	#0		START OF RESULT
	PSHS	A,B,X		SAVE VALUE AND MULTIPLIER
	LDX	#1		FIRST MULTIPLIER
GETD1	LDA	,-Y		GET DIGIT
	BSR	VALNUM		IS IT A VALID NUMBER
	BNE	GETD2		END OF NUMBER
	SUBA	#$30		CONVERT TO BINARY
	TFR	A,B		COPY TO B
	CLRA			CLEAR IT
	LBSR	MULT		TIMES MULTIPLIER
	ADDD	,S		ADD TO OLD VALUE
	STD	,S		RESAVE
	LDD	#10		TIMES 10
	LBSR	MULT		PERFORM
	TFR	D,X		COPY TO X
	BRA	GETD1		GET NEXT DIGIT
GETD2	CMPA	#'_'		NEGATIVE PREFIX?
	BNE	DETD3		NO, IT'S OK
	CLRA			GET A ZERO
	CLRB			FOR D ACCUMULATOR
	SUBD	,S		CONVERT NUMBER
	STD	,S		RESAVE
	LEAY	-1,Y		BACKUP
DETD3	PULS	A,B,X,PC	RESTORE VALUES
*
* LOOK UP ENTRY IN SYMBOL TABLE, ON EXIT, IF ENTRY IS FOUND, Z FLAG IS
* SET AND X POINTS TO A COPY OF THE SYMBOL TABLE ENTRY IN RAM. B HAS OFFSET
* FOR ADDRESS, AND A CONTAINS TYPE
* IF ENTRY IS NOT FOUND, Z FLAG IS CLEAR, AND X POINTS TO FIRST FREE SYMBOL
* TABLE SPACE
*
LOOKUP	LDX	#SYMTAB		POINT TO SYMBOL TABLE
CHKENT	PSHS	X,Y		SAVE REGSITERS
	LDB	,X+		GET LENGTH OF NAME
	ANDB	#$1F		REMOVE TYPE BITS
	BEQ	ENDST		DIDN'T FIND IT
	LDA	,X+		GET NEST INFO
	BNE	NOSYM		DON'T RECOGNISE IT
CHKV	LDA	,Y		GET CHARACTER FROM SOURCE
	CMPA	,X+		IS IT OK
	BNE	NOSYM		NOT A VARIABLE
	LEAY	-1,Y		BACKUP
	DECB			REDUCE COUNT
	BNE	CHKV		AND KEEP CHECKING
	LDA	,Y		GET CHARACTER FROM VARIABLE
	LBSR	VALSYM		VALID SYMBOL?
	BEQ	NOSYM		HAVN'T FOUND IT YET
	PULS	X		RESTORE TABLE POSITION
	LEAS	2,S		SKIP Y VALUE
	LBSR	SKBKP		SKIP BACK TO NEXT
	LDA	,X		GET LENGTH
	TFR	A,B		SAVE TYPE INFO IN B
	ANDB	#$1F		MASK OFF LENGTH
	ADDB	#2		SKIP TO TYPE BYTE
	LSRA			SHIFT
	LSRA			TYPE
	LSRA			BACK
	LSRA			TO
	LSRA			POSITION
	ORCC	#4		SET Z FLAG
	RTS
NOSYM	PULS	X,Y		RESTORE REGSTERS
	LDA	,X		ADVANCE TO NEXT
	ANDA	#$1F		MASK OFF TYPE
	ADDA	#4		ADD THREE BYTES FOR ADDRESS
	LEAX	A,X		SKIP TO NEXT ENTRY
	BRA	CHKENT		AND CHECK THIS ENTRY
ENDST	PULS	X,Y		RESTORE POINTER
	ANDCC	#$FB		CLEAR Z FLAG
	RTS
*
* CREATE A SYMBOL TABLE ENTRY, TYPE PASSED IN A
*
CRESYM	LSLA			SHIFT
	LSLA			TYPE INTO HIGH BITS
	LSLA			FOR ENTRY IN
	LSLA			SYMBOL
	LSLA			TABLE
	PSHS	A		SAVE TYPE
	LDX	#SYMTAB		POINT TO TABLE
CRE1	LDA	,X+		GET LINK
	ANDA	#$1F		MASK OFF LENGTH INFO
	BEQ	CRE2		END OF TABLE
	ADDA	#3		CONVERT TO COMPLETE OFFSET
	LEAX	A,X		SKIP THIS ENTRY
	BRA	CRE1		LOOK AGAIN
CRE2	CLRB			SET OFFSET
CRE3	LDA	,Y		GET CHARACTER FROM TEXT
	LBSR	VALSYM		IS IT VALID
	BNE	CRE4		NO MORE
	INCB			ADVANCE
	STA	B,X		SAVE SYMBOL IN TABLE
	LEAY	-1,Y		BACKUP TO NEXT
	BRA	CRE3		AND KEEP CREATING
CRE4	TFR	B,A		COPY TO A
	ORA	,S+		ADD IN TYPE BITS
	STA	-1,X		SAVE LENGTH IN TABLE
	CLR	,X		INDICATE LEVEL ZERO NEST
	INCB			SKIP TO TYPE FIELD IN ENTRY
	LEAX	B,X		ADVANCE POINTER
	LDD	FREE		POINT TO FREE MEMORY
	STD	,X		INDICATE WHERE SYMBOL WILL BE
	CLR	2,X		INDICATE LAST ENTRY
	RTS
*
* PERFORMS 16 BIT MULTIPLICATION (D=X*D)
*
MULT	PSHS	D,X		SAVE PARAMETERS
	LDA	1,S
	LDB	3,S
	MUL
	PSHS	A,B		RESAVE
	LDA	2,S
	LDB	5,S
	MUL
	ADDB	,S
	STB	,S
	LDA	3,S
	LDB	4,S
	MUL
	ADDB	,S
	STB	,S
	PULS	A,B		GET RESULT
	LEAS	4,S		SKIP CRAP
	RTS
*
* PERFORMS 16 BIT DIVISION. (X=X/D, D=REMAINDER.)
*
DIV	PSHS	D,X
	LDD			#0
	LDX			#17
DIV1	ANDCC			#$FE
DIV2	ROL			3,S
	ROL			2,S
	LEAX			-1,X
	BEQ			DIV3
	ROLB
	ROLA
	CMPD			,S
	BLO			DIV1
	SUBD			,S
	ORCC			#1
	BRA			DIV2
DIV3	LEAS	2,S
	PULS	X
	RTS
*
* GET FILENAME FROM INPUT LINE
*
FILNAM	PSHS	Y		SAVE Y
FIL1	LDA	,Y+		GET CHAR
	CMPA	#' '		SPACE?
	BEQ	FIL2		MARKS END
	CMPA	#$0D		CR?
	BNE	FIL1		NO, MORE FILENAME
FIL2	LDA	#'.'		GET DOT
	STA	-1,Y		SAVE
	LDD	#$4150		GET 'AP'
	STD	,Y++		SET UP IN NAME
	LDD	#$4C0D		GET 'L' AND CR
	STD	,Y		SET UP IN NAME
	PULS	Y		RESTORE FILENAME POINTER
	RTS
*
* EVALUATES AN EXPRESSION
*
EXPR	LDA	,Y+		GET CHARACTER
	CMPA	#$0D		END OF LINE?
	BNE	EXPR		KEEP LOOKING
EXEX	CLR	ERRFLG		INSURE NO ERROR SET
	LEAY	-1,Y		BACKUP
	PSHS	Y		SAVE IT
	BSR	DOEXPR		EXECUTE ROUTINE
	CMPA	#':'		LABEL DEFINITION?
	BEQ	EXEXE		IF SO, OK
	CMPA	#$0D		END OF LINE?
	BNE	EX1		NO, DON'T DISPLAY
EXEXE	TST	ASSFLG		WAS IT ASSIGNMENT
	BNE	EX1		NO, DON'T DISPLAY
	LDD	INPSTK		ARE WE INPUTTING?
	BNE	EX1		YES, DON'T OUTPUT
	LBSR	DISPLY		DISPLAY
	LBSR	LFCR		NEW LINE
EX1	PULS	Y,PC		GO HOME
* CALCULATE AN EXPRESSION
DOEXPR	CLR	ASSFLG		INSURE WE KNOW IF ASSIGNMENT
	LDD	TEMP5		GET FREE RAM ADDRESS
	SUBD	BUFSIZ		SUBTRACT WORK BUFFER
	CMPD	FREE		ARE WE OVER MEMORY LIMIT
	LBLS	WSFUL		INDICATE FULL
	STD	TEMP5		RESAVE
EXP1	LDX	TEMP5		POINT TO WORKSPACE
	LEAY	-1,Y		BACKUP
	LBSR	GETVAL		GET FIRST VALUE
	LBNE	SYNTAX		FIRST VALUE MUST EXIST
NXTOPR	LBSR	MVWRK		INSURE LAST RESULT IS IN WORKSPACE
	LBSR	SKBKP		GET NEXT OPERATOR
	STY	TXTPTR		SAVE OPERATOR LOCATION
	CMPA	#$0D		START OF LINE?
	BEQ	ENDEXP		IF SO, QUIT
	CMPA	#':'		LABEL?
	BEQ	ENDEXP		IF SO, EXIT
	CMPA	#'['		START OF INDEX EXPRESSON
	BEQ	ENDEXP		IF SO, QUIT
	CLR	ASSFLG		INSURE '(' DISPLAYS
	CMPA	#'('		START OF NESTED EXPRESSION
	BNE	DOEX1		NO, CALCULATE IT
ENDEXP	PSHS	A		SAVE ENDING CHARACTER
	LDD	TEMP5		POINT TO WORK BUFFER
	ADDD	BUFSIZ		RELEASE OUR LEVEL
	STD	TEMP5		AND RESAVE
	PULS	A,PC		GO HOME
* PERFORM OPERATION
DOEX1	LEAY	-1,Y		BACKUP TO LAST
* DETERMINE LENGTH OF PASSED STRUCTURE
DSIP1	CMPA	#'p'		CHECK FOR LENGTH
	BNE	DSIP2		NOT SHAPE
	LDD	1,X		GET LENGTH
	STD	3,X		AND SAVE IT
	LDD	#1		SET LENGTH TO 1
	STD	1,X		SET LENGTH
	STB	,X		SET TYPE TO INTEGER
	BRA	NXTOPR		AND GT NEXT OPERAND
* CREATE AN ASCENTING VECTOR
DSIP2	CMPA	#'i'		IS IT VECTOR?
	BNE	DSIP3		NO, TRY NEXT
	PSHS	X		SAVE POSITION
	LDA	,X+		GET TYPE
	CMPA	#1		INTEGER?
	LBNE	CDOM		NO, ERROR
	LDD	,X++		GET LENGTH
	CMPD	#1		SINGLE ELEMENT?
	LBNE	CLEN		NO, ERROR
	LDD	,X		GET DATA
	STD	-2,X		SET LENGTH
	BEQ	IOTZ		SPECIAL CASE
	ADDD	ORIGIN		ADVANCE
IOT1	SUBD	#1		REDUCE COUNT
	STD	,X++		SAVE
	CMPD	ORIGIN		ARE WE AT START YET?
	BNE	IOT1		AND GO BACK
IOTZ	PULS	X		RESTORE REGISTERS
	LBRA	NXTOPR
* REVERSE OPERAND VECTOR
DSIP3	CMPA	#'r'		REVERSE?
	BNE	DSIP4		NO, TRY NEXT
	PSHS	X,Y,U		SAVE REGISTERS
	LDD	1,X		GET LENGTH
	BEQ	REV2		NOTHING TO DO
	LEAY	3,X		GET START OF VECTOR
	TST	,X		WHAT FORM ARE WE
	BEQ	CREV		REVERSING CHARACTER ARRAY
	LSLB
	ROLA			DOUBLE FOR TWO BYTE ENTRIES
	LEAX	D,Y		POINT TO END OF STRING
REV1	LDD	,Y++		GET CHARACTER FROM START
	LDU	,--X		AND GET OTHER ONE
	PSHS	Y		SAVE
	CMPX	,S++		TEST FOR WRAPPED
	BLO	REV2		IF SO, WE ARE DONE
	STD	,X		SAVE NEW RESULT
	STU	-2,Y		AND OTHER ONE
	BRA	REV1		KEEP GOING
CREV	LEAX	D,Y		SKIP TO END
REV3	LDA	,-X		GET CHARACTER
	LDB	,Y+		AND GET OTHER CHARACTER
	PSHS	Y		SAVE REG
	CMPX	,S++		ARE WE THERE?
	BLO	REV2		IF SO, EXIT
	STB	,X		SET NEW VALUE
	STA	-1,Y		AND NEW VALUE HERE
	BRA	REV3		CONTINUE REVERSING
REV2	PULS	X,Y,U		RESTORE REGISTERS
	LBRA	NXTOPR		NEXT OPERATOR
* GENERATE RANDOM VECTORS
DSIP4	CMPA	#'?'		RANDOM OPERATOR?
	BNE	DSIP5		NO, TRY NEXT
	PSHS	X,Y		SAVE REGISTERS
	LDA	,X+		GET TYPE
	LBEQ	CDOM		CAN'T USE CHARACTERS
	LDY	,X++		GET LENGTH
	BEQ	RND2		ZERO LENGTH, SKIP IT
RND1	PSHS	X		SAVE POINTER
	LDD	SEED		GET RANDOM SEED
	LDX	#13709		GET FIRST VALUE
	LBSR	MULT		MULTIPLY IT
	ADDD	#13849		AND DO THE ADDITION
	STD	SEED		RESAVE SEED
	TFR	D,X		COPY FOR DIV
	LDD	[,S]		GET LIMIT VALUE
	BEQ	RND3		ZERO, RESULT IS ZERO
	LBSR	DIV		PERFORM DIVISION
	ADDD	ORIGIN		CONVERT FOR ORIGIN VALUE
RND3	PULS	X		RESTORE POINTER
	STD	,X++		SAVE BACK IN VECTOR
	LEAY	-1,Y		REDUCE LENGTH
	BNE	RND1		DO THEM ALL
RND2	PULS	X,Y		RESTORE REGISTERS
	LBRA	NXTOPR
* CLASSIFY DATA TYPE
DSIP5	CMPA	#'c'		IS IT CLASSIFY?
	BNE	DSIP6		NO, TRY NEXT
	LDB	,X		GET TYPE
	CLRA			ZERO HIGH BYTE
	STD	3,X		SAVE DATA
	LDB	#1		GET LENGTH + TYPE
	STD	1,X		SAVE LENGTH
	STB	,X		SAVE TYPE
	LBRA	NXTOPR
* GENERATE ASSENDING VECTOR INDEX
DSIP6	CMPA	#'^'		ASSEND?
	LBNE	DSIP7		NO, TRY NEXT
	PSHS	Y,U		SAVE REGISTERS
	LEAX	1,X		SKIP TO DATA
	LDY	FREE		POINT TO FREE RAM
	LDD	,X		GET LENGTH
	LEAU	D,Y		ADVANCE FOR FLAG VECTOR SPACE
	PSHS	U		SAVE FREE LOCATION
	BEQ	ASC8		ZERO LENGTH, NOTHING TO DO
ASC0	CLR	,Y+		CLEAR ONE FLAG
	SUBD	#1		REDUCE COUNT
	BNE	ASC0		CLEAR THEM ALL
ASC8	LDA	#1		RESULT IS ALWAYS AN INTEGER
	STA	,U+		SET TYPE OF RESULT
	LDD	,X++		GET LENGTH AGAIN
	STD	,U++		SET LENGTH OF RESULT
	BEQ	ASC1		IF ZERO LENGTH, NOTHING TO DO
	TFR	D,Y		SAVE LENGTH
	STD	TEMP1		AND KEEP IT
	LDA	-3,X		GET TYPE
	BEQ	ASC5		CHARACTER SORT
ASC2	PSHS	X,Y		SAVE REGISTERS
	PSHS	U		SAVE LOCATION
	CLRA			START
	CLRB			WITH ZERO
	LDY	TEMP1		GET LENGTH
	LDU	FREE		POINT TO FLAG VECTOR
ASC3	TST	,U+		TEST FOR ELEMENT ALREADY SELECTED
	BNE	ASC4		IF SO, DON'T LOOK AT IT
	CMPD	,X		TEST FOR SMALLEST ELEMENT
	BHI	ASC4		NO, SKIP IT
	STY	TEMP3		SAVE ELEMENT NUMBER
	STU	TEMP2		SAVE FLAG VECTOR ADDRESS
	LDD	,X		USE THIS AS THE NEW VALUE
ASC4	LEAX	2,X		SKIP TO NEXT ELEMENT
	LEAY	-1,Y		REDUCE COUNT
	BNE	ASC3		KEEP GOING TILL WE DO IT ALL
	LDX	TEMP2		GET FLAG VECTOR ADDRESS
	DEC	-1,X		SET FLAG
	PULS	U		RESTORE RESULT ADDRESS
	LDD	TEMP3		GET ELEMENT NUMBER
	SUBD	#1		CONVERT TO ZERO OFFSET
	ADDD	ORIGIN		AND ADJUST FOR ORIGIN
	STD	,U++		SAVE IN RSULT
	PULS	X,Y		RESTORE POINTERS
	LEAY	-1,Y		REDUCE REMAINING COUNT
	BNE	ASC2		AND DO THEM ALL
ASC1	PULS	X,Y,U		RESTORE POINTERS
	LBRA	NXTOPR
ASC5	PSHS	X,Y		SAVE REGISTERS
	PSHS	U		SAVE LOCATION
	CLRA			START
	LDY	TEMP1		GET LENGTH
	LDU	FREE		POINT TO FLAG VECTOR
ASC6	TST	,U+		TEST FOR ELEMENT ALREADY SELECTED
	BNE	ASC7		IF SO, DON'T LOOK AT IT
	CMPA	,X		TEST FOR SMALLEST ELEMENT
	BHI	ASC7		NO, SKIP IT
	STY	TEMP3		SAVE ELEMENT NUMBER
	STU	TEMP2		SAVE FLAG VECTOR ADDRESS
	LDA	,X		USE THIS AS THE NEW VALUE
ASC7	LEAX	1,X		SKIP TO NEXT ELEMENT
	LEAY	-1,Y		REDUCE COUNT
	BNE	ASC6		KEEP GOING TILL WE DO IT ALL
	LDX	TEMP2		GET FLAG VECTOR ADDRESS
	DEC	-1,X		SET FLAG
	PULS	U		RESTORE RESULT ADDRESS
	LDD	TEMP3		GET ELEMENT NUMBER
	SUBD	#1		CONVERT TO ZERO OFFSET
	ADDD	ORIGIN		AND ADJUST FOR ORIGIN
	STD	,U++		SAVE IN RSULT
	PULS	X,Y		RESTORE POINTERS
	LEAY	-1,Y		REDUCE REMAINING COUNT
	BNE	ASC5		AND DO THEM ALL
	BRA	ASC1		GO HOME
* EXECUTE STRING
DSIP7	CMPA	#'e'		EXECUTE?
	BNE	DSIP8		NO, TRY STRING FORMAT
	LDA	,X+		GET TYPE
	LBNE	CDOM		NOT VALID
	LDD	,X++		GET LENGTH OF STRING
	BEQ	NOEXEC		NOTHING TO EXECUTE
	CMPD	#128		ARE WE OVER LENGTH
	LBHS	CLEN		INDICATE EXEC OVER 255 CHARACTERS
	PSHS	Y		SAVE POINTERS
	LEAY	B,X		POINT TO BUFFER
	TFR	Y,X		COPY TO X
	LDA	#$0D		GET CR
	STA	,Y+		SAVE IT
DS71	LDA	,-X		GET CHARACTER FROM BUFFER
	STA	,Y+		SAVE IN OUTPUT
	DECB			REDUCE COUNT
	BNE	DS71		CONTINUE
	LDA	#$0D		GET CR
	STA	,Y		SAVE IT
	LBSR	DOEXPR		PERFORM EXPRESSION
	PULS	Y		RESTORE Y REGISTER
DS72	LBRA	NXTOPR		GET NEXT OPERAND
* EXECUTE OF NULL LENGTH VECTOR, DO NOTHING, NO OUTPUT
NOEXEC	LDX	#IOTA0		POINT TO DEFAULT PARAMETER
	DEC	ASSFLG		DON'T DISPLAY EXECUTE OF NULL
	BRA	DS72		AND GO HOME
* FORMAT NUMERIC VALUE TO STRING
DSIP8	CMPA	#'s'		IS IT FORMAT STRING?
	BNE	BRANCH		NO, TRY BRANCH
	PSHS	Y,U		SAVE REGISTERS
	LDU	FREE		AND A PLACE TO PUT IT
	CLR	,U+		CHARACTER DATA
	LEAU	2,U		ADVANCE PAST LENGTH FOR NOW
	LDY	#0		LENGTH OF OUTPUT
	LDA	,X+		GET TYPE
	LBEQ	CDOM		INDICATE DOMAIN ERROR
	LDD	,X++		GET LENGTH
	BEQ	DECS1		EXIT IF ZERO
DECS2	PSHS	A,B,X		SAVE REGISTERS
	LDX	,X		GET NUMBER TO DISPLAY
DECS	LDD	#10		DIVIDE BY 10
	LBSR	DIV		PERFORM DIVISION
	ORB	#$30		CONVERT TO NUMBER
	STB	,U+		SAVE DIGIT
	LEAY	1,Y		ADVANCE LENGTH
	CMPX	#0		OVER YET?
	BNE	DECS		NO, KEEP GOING
	PULS	A,B,X		RESTORE REGISTERS
	SUBD	#1		ARE WE DONE?
	BEQ	DECS1		IF SO, QUIT
	PSHS	A		SAVE A
	LDA	#' '		GET SPACE
	STA	,U+		SAVE
	PULS	A		RESTORE
	LEAY	1,Y		ADVANCE LENGTH
	LEAX	2,X		ADVANCE TO NEXT
	BRA	DECS2		AND CONTINUE
DECS1	LDX	FREE		POINT TO OUTPUT
	STY	1,X		SET UP LENGTH
	PULS	Y,U		RESTORE REGS
	LBRA	NXTOPR		AND GET NEXT
* BRANCH OPERATOR
BRANCH	CMPA	#'b'		IS IT BRANCH?
	BNE	TRAVEL		NO, TRY TRAVEL
	LDA	,X		GET TYPE
	LBEQ	CDOM		INDICATE DOMAIN ERROR
	LDD	1,X		GET LENGTH
	BEQ	NOBRA		DON'T BRANCH
	CMPD	#1		IS IT PROPER LENGTH?
	LBNE	CLEN		INDICATE LENGTH ERROR
	LDD	3,X		GET VALUE
	STD	GOTO		SAVE IN FLAG
NOBRA	DEC	ASSFLG		INSURE NO JUMP
	LBRA	NXTOPR		GO FOR IT
* OPERATOR TRAVEL
TRAVEL	CMPA	#'\'		IS IT TRAVEL
	LBNE	REDUC		NO, TRY REDUCTION
	LBSR	SKBKP		GET NEXT OPERATOR
	TST	,X		TEST TYPE OF OPERAND
	LBEQ	CDOM		NOT VALID WITH CHARACTER
	PSHS	X,Y		SAVE REGISTERS
	LDB	#1		GET TYPE OF RESULT
	STB	,X+		SAVE TYPE
	LDY	,X		GET LENGTH
	LEAY	1,Y		CONVERT
	CLRA			ZERO HIGH BYTE
	STD	,X++		SAVE NEW LENGTH
	LDA	[2,S]		GET OPERATOR BACK
	CMPA	#'+'		ADDITION?
	BNE	CMP1		NO, TRY MULTIPLY
	CLRA
	CLRB			INITIAL VALUE IS ZERO
CMPA	LEAY	-1,Y		REDUCE COUNT
	BEQ	CMP9		END OF OPERAND, QUIT
	ADDD	,X++		ADD NEXT ELEMENT
	BRA	CMPA		DO NEXT
CMP1	CMPA	#'x'		MULTIPLY?
	BNE	CMP2		NO, TRY LOGICAL AND
	LDD	#1		INITIAL VALUE IS ONE
CMPB	LEAY	-1,Y		REDUCE COUNT
	BEQ	CMP9		END OF OPERAND, QUIT
	PSHS	X		SAVE POINTER TO OPERAND
	LDX	,X		GET VALUE
	LBSR	MULT		PERFORM MULTIPLY
	PULS	X		RESTORE POINTER
	LEAX	2,X		ADVANCE TO NEXT
	BRA	CMPB		GO AGAIN
CMP2	CMPA	#'&'		LOGICAL AND?
	BNE	CMP3		NO, TRY LOGICAL OR
	LDD	#$FFFF		INTIAL VALUE
CMPC	LEAY	-1,Y		REDUCE COUNT
	BEQ	CMP9		END, QUIT
	ANDA	,X+		AND HIGH BYTE
	ANDB	,X+		AND LOW BYTE
	BRA	CMPC		AND CONTINUE
CMP3	CMPA	#'!'		LOGICAL OR?
	BNE	CMP6		NO, TRY XOR
	CLRA
	CLRB			START WITH ZERO
CMPD	LEAY	-1,Y		REDUCE COUNT
	BEQ	CMP9		END, QUIT
	ORA	,X+		OR HIGH BYTE
	ORB	,X+		OR LOW BYTE
	BRA	CMPD		GO AGAIN
CMP9	PULS	X,Y		RESTORE REGISTERS
	LEAY	-1,Y		BACKUP PAST OPERATOR
	STD	3,X		SAVE VALUE OR RESULT
	LBRA	NXTOPR		AND GET NEXT
CMP6	CMPA	#'|'		XOR?
	BNE	CMP4		NO, TRY GREATOR OF
	CLRA
	CLRB			START WITH ZERO
CMPZ	LEAY	-1,Y		REDUCE COUNT
	BEQ	CMP9		END IF DONE
	EORA	,X+		XOR HIGH BYTE
	EORB	,X+		XOR LOW BYTE
	BRA	CMPZ		CONTINUE
CMP4	CMPA	#'g'		GREATOR OF?
	BNE	CMP5		NO, TRY LESS OF
	CLRA
	CLRB			START WITH ZERO
CMPE	LEAY	-1,Y		REDUCE COUNT
	BEQ	CMP9		END, QUIT
	CMPD	,X++		TEST FOR GREATOR
	BHS	CMPE		NO, SKIP IT
	LDD	-2,X		REPLACE VALUE
	BRA	CMPE		AND TRY AGAIN
CMP5	CMPA	#'l'		LESS OF?
	BNE	CSYNT		NO, GET UPSET
	LDD	#$FFFF		START WITH FFFF
CMPF	LEAY	-1,Y		REDUCE COUNT
	BEQ	CMP9		END, QUIT
	CMPD	,X++		TEST FOR LESS
	BLS	CMPF		NO, SKIP IT
	LDD	-2,X		REPLACE VALUE
	BRA	CMPF		AND GO AGAIN
CSYNT	LDY	TXTPTR		POINT TO TEXT
	LBRA	SYNTAX
*
* EXTRACT OPERATOR
*
REDUC	CMPA	#'/'		EXTRACT?
	LBNE	DYADIC		NO, TRY DYADIC FUNCTIONS
	PSHS	X,U		SAVE REGISTERS
	LBSR	GETPRM		GET PARAMETER
	LDU	,S		GET POINTER BACK
	LDA	,X+		GET TYPE OF OPERAND?
	LBEQ	CDOM		DOMAIN ERROR IF CHARACTER
	CLRA
	CLRB			GET A ZERO
	STD	TEMP		CLEAR LENGTH SAVER
	LDD	,X++		GET LENGTH
	PSHS	Y		SAVE Y POINTER
	CMPD	1,U		IS LENGTH THE SAME?
	LEAU	3,U		SKIP TO DATA
	TFR	U,Y		SAVE FOR LATER
	BNE	RED1		NO, TRY SCALER OPERATION
	ADDD	#1		ADVANCE
	TST	-3,U		CHARACTER?
	BEQ	RED5		DO IT FOR CHARACTER
RED2	SUBD	#1		DEC. COUNT
	BEQ	RED3		SAVE
	PSHS	A,B		SAVE
	LDD	,X++		TEST FOR NUMBER
	BEQ	RED4		DON'T INCLUDE THIS ELEMENT
	LDD	,U		GET ELEMENT
	STD	,Y++		SAVE IN OUTPUT
	LDD	TEMP		GET LENGTH
	ADDD	#1		ADVANCE
	STD	TEMP		RESAVE
RED4	PULS	A,B		RESTORE
	LEAU	2,U		ADVANCE
	BRA	RED2		RESAVE
RED3	LDD	TEMP		GET LENGTH
	BRA	RED9		SET LENGTH
RED1	CMPD	#1		TEST FOR LENGTH 1?
	LBNE	CLEN		INVALID
	LDD	,X		GET VALUE
	BNE	RED8		WORKED
	CLRA
	CLRB			ZERO LENGTH
RED9	PULS	Y		RESTORE POINTER
	PULS	X,U		AND REGISTERS
	STD	1,X		SET LENGTH
	LBRA	NXTOPR
RED8	PULS	Y		RESTORE Y
	PULS	X,U		RESTORE POINTERS
	LBRA	NXTOPR
RED5	SUBD	#1		DEC. COUNT
	BEQ	RED3		SAVE
	PSHS	A,B		SAVE ACC
	LDD	,X++		TEST FOR NUMBER
	BEQ	RED6		DON'T INCLUDE THIS ELEMENT
	LDA	,U		GET ELEMENT
	STA	,Y+		SAVE IN OUTPUT
	LDD	TEMP		GET LENGTH
	ADDD	#1		ADVANCE
	STD	TEMP		RESAVE
RED6	PULS	A,B		RESTORE
	LEAU	1,U		ADVANCE
	BRA	RED5		RESAVE
*
* DYADIC OPERATORS
*
DYADIC	CMPA	#';'		IS IT JOIN?
	BNE	SEARCH		NO, TRY NEXT
	PSHS	X,Y,U		SAVE REGISTERS
	LBSR	GETPRM		GET OPERAND VALUE
	STY	2,S		SAVE NEW TEXT POSITION
	LDU	,S		GET OLD OPERAND LOCATION
	LDA	,U+		GET TYPE FOR OLD OPERAND
	CMPA	,X+		TEST AGAIN OTHER OPERAND TYPE
	LBNE	CDOM		MISMATCHED, ERROR
	LDD	,X++		GET LENGTH OF NEW OPERAND
	BEQ	CON1		IF ZERO, IT'S OK
	PSHS	A,B		SAVE LENGTH
	ADDD	,U		ADD TO OLD OPERAND LENGTH
	LDY	,U		GET OLD LENGTH
	STD	,U++		SAVE NEW LENGTH VALUE
	TFR	Y,D		PUT OLD LENGTH IN D
	PULS	Y		GET NEW LENGTH IN Y
	TST	-3,U		CHECK FOR CHARACTER DATA
	BEQ	CON3		IT'S CHARACTER
	LSLB
	ROLA			DOUBLE FOR WORD ELEMENTS
	LEAU	D,U		OFFSET TO NEW LOCATION
CON2	LDD	,X++		GET ELEMENT FROM OLD OPERAND
	STD	,U++		SAVE IN NEW OPERAND
	LEAY	-1,Y		REDUCE COUNT
	BNE	CON2		GO AGAIN
CON1	PULS	X,Y,U		RESTORE REGISTERS
	LBRA	NXTOPR
CON3	LEAU	D,U		SKIP TO END OF CHARACTER ARRAY
CON4	LDA	,X+		GET CHARACTER FROM OLD
	STA	,U+		SAVE IN NEW
	LEAY	-1,Y		REDUCE COUNT
	BNE	CON4		GO AGAIN
	BRA	CON1		AND GO HOME
* FIND SUBSTRING
SEARCH	CMPA	#'f'		IS IT SEARCH?
	LBNE	ADROP		NO, TRY EQUALS TEST
	PSHS	X,U		SAVE REGS
	LBSR	GETPRM		GET PARAMETER VALUE
	LDU	,S		GET OLD OPERAND POINTER BACK
	LDA	,X		GET TYPE
	CMPA	,U+		IS IT SAME?
	LBNE	CDOM		NO, ERROR
	STA	TEMP1		SAVE FOR LATER REF
	PSHS	Y		SAVE TEXT POINTER
	LDD	,U++		GET LENGTH OF STRING WE LOOK FOR
	LBEQ	CLEN		INDICATE INVALID LENGTH
	LDY	1,X		GET LENGTH OF SOURCE STRING
	STY	TEMP2		SAVE FOR LATER REF
	LBSR	CALLEN		GET LENGTH
	LEAX	D,X		ADVANCE TO NEXT
	EXG	X,U		SWAP
	STX	TEMP		SAVE BACKUP POSITION
	LEAX	-3,X		BACKUP TO START
	LBSR	CALLEN		CALCULATE LENGTH
	LEAX	D,X		SKIP TO END
	PSHS	X		SAVE POINTER
	LEAY	1,Y		ADVANCE FOR DEC
	TST	TEMP1		CHARACTER VALUES?
	BEQ	SER1		LOOK FOR CHARACTER STRING
SER2	LEAY	-1,Y		BACKUP
	BEQ	SER7		GO FOR IT
	LDD	,--U		GET VALUE FROM SOURCE
	CMPD	,--X		MATCH?
	BEQ	SER3		OK
	LDX	,S		RESTORE POINTER
	BRA	SER2
SER3	CMPX	TEMP		HAVE WE REACHED END?
	BNE	SER2		NO, WE ARE STILL HERE
SER5	TFR	Y,D		GET VALUE
	LDX	TEMP		POINT TO DATA SPACE
	ADDD	-2,X		BACKUP TO FIRST CHARACTER OF SUBSTRING
	PSHS	A,B		SAVE
	LDD	TEMP2		GET LENGTH
	SUBD	,S++		AND CALCULATE FINAL VALUE
	ADDD	#1		CONVERT TO PROPER OFFSET
SER8	ADDD	ORIGIN		AND OFFSET FOR ORIGIN VALUE
	PULS	U		RESTORE POINTER
	PULS	Y		RESTORE Y POINTER
	PULS	X,U		RESTORE X POINTER
	STD	3,X		SAVE VALUE
	LDD	#1		LENGTH/TYPE=1
	STB	,X		SET TYPE
	STD	1,X		SET LENGTH
	LBRA	NXTOPR		GET NEXT OPERAND
SER7	LDD	TEMP2		GET OPERAND LENGTH
	BRA	SER8
SER1	LEAY	-1,Y		BACKUP
	BEQ	SER7		GO FOR IT
	LDA	,-U		GET VALUE FROM SOURCE
	CMPA	,-X		MATCH?
	BEQ	SER6		OK
	LDX	,S		RESTORE POINTER
	BRA	SER1
SER6	CMPX	TEMP		HAVE WE REACHED END?
	BNE	SER1		NO, WE ARE STILL HERE
	BRA	SER5		GO HOME
* DROP ELEMENTS FROM START OF VECTOR
ADROP	CMPA	#'d'		DROP?
	BNE	TAKE		NO, TRY NEXT
	PSHS	X,U		SAVE REGISTERS
	LBSR	GETPRM		GET FORWARD PARAMETER
	LDU	,S		RESTORE REGISTERS
	LDA	,X+		GET TYPE
	LBEQ	CDOM		INDICATE DOMAIN ERROR
	LDD	,X++		GET LENGTH
	CMPD	#1		INSURE LENGTH OF ONE
	LBNE	CLEN		INDICATE BAD LENGTH
	LEAU	1,U		SKIP TYPE
	LDD	,U		GET LENGTH
	SUBD	,X		PERFORM DROP
	BCC	DRP1		ALL IS OK
	CLRA
	CLRB			SET LENGTH TO ZERO
DRP1	STD	,U		SET NEW LENGTH,
	PULS	X,U		RESTORE REGISTERS
	LBRA	NXTOPR		GET NEXT OPERATOR
* TAKE A NUMBER OF ELEMENTS FROM THE START OF A STRUCTURE
TAKE	CMPA	#'t'		TAKE?
	BNE	MEMBER		NO, TRY SOMETING ELSE
	PSHS	X,U		SAVE REGISTERS
	LBSR	GETPRM		GET PARAMETER
	PULS	U		GET POINTER TO OLD
	LDA	,X+		GET TYPE OF NEW
	LBEQ	CDOM		INDICATE INVALID
	LDD	,X++		GET LENGTH?
	CMPD	#1		IS IT ONE?
	LBNE	CLEN		INDICATE LENGTH ERROR
	PSHS	Y		SAVE TEXT POINTER
	LDY	,X++		GET REQUESTED LENGTH
	TFR	U,X		COPY TO X
	LEAU	3,U		ADVANCE TO DATA SPACE
	STU	TEMP		SAVE
	LDU	FREE		GET POINTER TO FREE SPACE
	STY	1,U		SAVE LENGTH
	LDA	,X		GET TYPE OF OLD
	STA	,U		AND SAVE
	PSHS	A		SAVE ON STACK
	LBSR	CALLEN		CALCULATE LENGTH
	LEAX	D,X		SKIP TO END
	EXG	X,U		SWAP
	LBSR	CALLEN		LENGTH OF NEW
	LEAX	D,X		SKIP TO END
	LEAY	1,Y		ADVANCE
	TST	,S+		CHECK TYPE
	BEQ	TAK4		TAKEING A CHARACTER
TAK1	CMPU	TEMP
	BLS	TAK12
	LEAY	-1,Y		BACKUP
	BEQ	TAK2		END, QUIT
	LDD	,--U		GET FROM OLD
	STD	,--X		SAVE IN NEW
	BRA	TAK1
TAK12	CLRA
	CLRB			START WITH ZERO
TAK3	LEAY	-1,Y		BACKUP
	BEQ	TAK2		EXIT IF END
	STD	,--X		RESAVE
	BRA	TAK3		GO AGAIN
TAK2	PULS	Y,U		RESTORE TEXT POINTER
	LDX	FREE		POINT TO NEW VALUE
	LBRA	NXTOPR		GO AGAIN
TAK4	CMPU	TEMP
	BLS	TAK41
	LEAY	-1,Y		BACKUP
	BEQ	TAK2		END, QUIT
	LDA	,-U		GET FROM OLD
	STA	,-X		SAVE IN NEW
	BRA	TAK4		NO, IT'S OK
TAK41	LDA	#' '		GET SPACE
TAK5	LEAY	-1,Y		BACKUP
	BEQ	TAK2		EXIT IF END
	STA	,-X		RESAVE
	BRA	TAK5		GO AGAIN
* MEMBER, DETERMINE IF EACH ELEMENT IS A MEMBER OF THE OTHER SET
MEMBER	CMPA	#'u'		MEMBER OPERATOR?
	BNE	XLATE		NO, TRY TRANSLATE
	PSHS	X,U		SAVE REGS
	LBSR	GETPRM		GET PARAMETER
	PULS	U		GET REGISTER
	PSHS	Y		SAVE REGISTERS
	LDA	,U+		GET TYPE OF FIRST
	CMPA	,X+		SAME AS SECOND?
	LBNE	CDOM		NO, GET UPSET
	LDD	FREE		GET FREE POINTER
	ADDD	BUFSIZ		GET SECOND BUFFER
	TFR	D,Y		POINT U AT IT
	PSHS	A,B		SAVE IT
	LDA	#1		INTEGER
	STA	,Y+		SET TYPE
	LDD	,X++		GET LENGTH OF RIGHT OPERATOR
	STD	,Y++		SAVE IT
	BEQ	MEMEND		SPECIAL CASE, QUIT
	TST	-3,X		IS IT CHARACTER?
	BEQ	MEMCHR		IF SO, DO IT FOR CHARACTERS
MEMLP	PSHS	A,B,Y,U		SAVE REGS
	LDD	,X++		GET ELEMENT WE ARE TESTING
	LDY	,U++		GET LENGTH OF LEFT OPERAND
	BEQ	MEML0		DOES NOT EXIST
MEMLX	CMPD	,U++		DUZ IT MATCH
	BEQ	MEML1		OK
	LEAY	-1,Y		REDUCE COUNT
	BNE	MEMLX		CONTINUE
MEML0	CLRB
	BRA	MEML2		CONTINUE
MEML1	LDB	#1		INDICATE FOUND
MEML2	CLRA			ZERO HIGH BYTE
	LDY	2,S		GET POINTER
	STD	,Y		SAVE
	PULS	A,B,Y,U		RESTORE REGS
	LEAY	2,Y		ADVANCE
	SUBD	#1		MORE ELEMENTS
	BNE	MEMLP		CONTINUE
	BRA	MEMEND
MEMCHR	PSHS	A,B,Y,U		SAVE REGS
	LDA	,X+		GET ELEMENT WE ARE TESTING
	LDY	,U++		GET LENGTH OF LEFT OPERAND
	BEQ	MEMC0		DOES NOT EXIST
MEMCX	CMPA	,U+		DOS IT MATCH
	BEQ	MEMC1		OK
	LEAY	-1,Y		REDUCE COUNT
	BNE	MEMCX		CONTINUE
MEMC0	CLRB
	BRA	MEMC2		CONTINUE
MEMC1	LDB	#1		INDICATE FOUND
MEMC2	CLRA			ZERO HIGH BYTE
	LDY	2,S		GET POINTER
	STD	,Y		SAVE
	PULS	A,B,Y,U		RESTORE REGS
	LEAY	2,Y		ADVANCE
	SUBD	#1		MORE ELEMENTS
	BNE	MEMCHR		CONTINUE
MEMEND	PULS	X,Y,U		RESTORE REGS
	LBRA	NXTOPR		CONTINUE
* TRANSLATE TABLE LOOKUP
XLATE	CMPA	#'n'		TRANSLATE OPERATOR?
	LBNE	OPSYS		NO, TRY OPSYS
	PSHS	X,U		SAVE REGS
	LBSR	GETPRM		GET PARAMETER
	PULS	U		GET REGISTER
	PSHS	Y		SAVE REGISTERS
	LDA	,U+		GET TYPE OF FIRST
	CMPA	,X+		SAME AS SECOND?
	LBNE	CDOM		NO, GET UPSET
	LDD	FREE		GET FREE POINTER
	ADDD	BUFSIZ		GET SECOND BUFFER
	TFR	D,Y		POINT U AT IT
	PSHS	A,B		SAVE IT
	LDA	#1		INTEGER
	STA	,Y+		SET TYPE
	LDD	,U++		GET LENGTH OF RIGHT OPERATOR
	STD	,Y++		SAVE IT
	BEQ	XLAEND		SPECIAL CASE, QUIT
	TST	-1,X		IS IT CHARACTER?
	BEQ	XLACHR		IF SO, DO IT FOR CHARACTERS
XLALP	PSHS	A,B,X,Y		SAVE REGS
	LDD	,U++		GET ELEMENT WE ARE TESTING
	LDY	,X++		GET LENGTH OF LEFT OPERAND
	BEQ	XLAL0		DOES NOT EXIST
XLALX	CMPD	,X++		DUZ IT MATCH
	BEQ	XLAL1		OK
	LEAY	-1,Y		REDUCE COUNT
	BNE	XLALX		CONTINUE
XLAL0	LDY	[2,S]		POINT TO END
	LEAY	1,Y		ADVANCE PAST END
XLAL1	LEAY	-1,Y		BACKUP TO ORIGIN ZERO
	TFR	Y,D		COPY
	ADDD	ORIGIN		OFFSET
	LDY	4,S		GET POINTER
	STD	,Y		SAVE
	PULS	A,B,X,Y		RESTORE REGS
	LEAY	2,Y		ADVANCE
	SUBD	#1		MORE ELEMENTS
	BNE	XLALP		CONTINUE
	BRA	XLAEND
XLACHR	PSHS	A,B,X,Y		SAVE REGS
	LDA	,U+		GET ELEMENT WE ARE TESTING
	LDY	,X++		GET LENGTH OF LEFT OPERAND
	BEQ	XLAC0		DOES NOT EXIST
XLACX	CMPA	,X+		DOS IT MATCH
	BEQ	XLAC1		OK
	LEAY	-1,Y		REDUCE COUNT
	BNE	XLACX		CONTINUE
XLAC0	LDY	[2,S]		GET HIGHEST VALIE
	LEAY	1,Y		BACKUP TO ORIGIN ZERO
XLAC1	LEAY	-1,Y		ADVANCE
	TFR	Y,D		COPY TO D
	ADDD	ORIGIN		CONVERT
	LDY	4,S		GET POINTER
	STD	,Y		SAVE
	PULS	A,B,X,Y		RESTORE REGS
	LEAY	2,Y		ADVANCE
	SUBD	#1		MORE ELEMENTS
	BNE	XLACHR		CONTINUE
XLAEND	PULS	X,Y,U		RESTORE REGS
	LBRA	NXTOPR		CONTINUE
*
	include	MAPL.1
