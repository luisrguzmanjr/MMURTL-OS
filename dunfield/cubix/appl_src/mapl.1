* OPERATING SYSTEM INTERFACE
OPSYS	CMPA	#'o'		OPERATING SYSTEM INTERFACE?
	BNE	EQUTST		NO, TRY EQUALITY TEST
	PSHS	X,Y,U		SAVE OPERAND POINTER
	LBSR	GETPRM		GET PARAMETER
	STY	2,S		RESET LINE PTR
	LDY	,S		'Y' POINTS TO FIRST
	LBSR	OSFUNC		EXECUTE OS FUNCTION
	PULS	X,Y,U		RESTORE ALL REGS
	LBRA	NXTOPR		AND GET NEXT OPERATOR
* EQUALS AND ASSOCIATED FUNCTIONS
EQUTST	CMPA	#'='		EQUALS?
	LBNE	DYFNS		NO, SKIP IT
	PSHS	X,U		SAVE U REGISTER
	LDA	,Y		GET NEXT OPERAND
	LEAY	-1,Y		BACKUP
	LDU	#DYGE		INDICATE GREATER/EQUALS
	CMPA	#'>'		TEST FOR GE
	BEQ	DODYA1		DO IT
	LDU	#DYLE		TEST FOR LT
	CMPA	#'<'		IS THIS IT?
	BEQ	DODYA1		IF SO, DO IT
	LDU	#DYEQ		POINT AT HANDLER
	CMPA	#'='		EQUALS
	BNE	EQU1		NOT IT
	TST	,X		IS IT NUMERIC?
	BEQ	CEQU		IT'S CHARACTER
DODYA1	LBRA	DODYA		GO FOR IT
* CHARACTER EQUALITY TEST
EQU1	LDU	#DYNE		POINT AT IT
	CMPA	#'-'		IS THIS IT?
	BNE	EQU9		MUST BE ASSIGNMENT
	TST	,X		IS THIS IT?
	BNE	DODYA1		GO FOR IT
CEQU	LDU	#DCEQU		POINT TO EQUALS
	CMPA	#'='		IS IT EQUALS
	BEQ	CEQ2		IT'S OK
	LDU	#DCNEQ		POINT TO NOT EQUALS
CEQ2	STU	TEMP2		SAVE POINTER
	LBSR	GETPRM		GET SECOND OPERAND
	TST	,X+		TEST FOR TYPE
	LBNE	CDOM		INVALID
	LDU	,S		POINT TO OLD PARM
	LEAU	1,U		SKIP TYPE
	LDD	,X++		GET LENGTH
	CMPD	,U++		ARE THEY THE SAME?
	BNE	CEQU1		NO, TRY SCALAR COMPARISIONS
	ADDD	#1		ADVANCE FOR LATER DEC
CEQ1	SUBD	#1		BACKUP
	BEQ	CEQ3		END, GET OUT
	PSHS	A		SAVE REGISTERS
	JSR	[TEMP2]		PERFORM IT
	LEAX	1,X		NEXT
	PULS	A		GET THEM BACK
	BRA	CEQ1		AND DO IT
CEQU1	CMPD	#1		IS THIS A SCALAR?
	BNE	CEQU2		NO, TRY NEXT
	LDD	-2,U		GET LENGTH BACK
	ADDD	#1		ADVANCE FOR LATER DEC
CEQ4	SUBD	#1		DEC
	BEQ	CEQ3		GET OUT
	PSHS	A		SAVE IT
	JSR	[TEMP2]		DO IT
	PULS	A		RESTORE
	BRA	CEQ4		GO AGAIN
CEQU2	LDD	-2,U		GET IT
	CMPD	#1		IS THIS IT?
	LBNE	CLEN		GET REAL
	LDD	-2,X		GET LENGTH BACK
	STD	-2,U		SET OUTPUT LENGTH
	ADDD	#1		ADVANCE
CEQ5	SUBD	#1		DECREMENT COUNTER
	BEQ	CEQ3		QUIT IF DONE
	PSHS	A		SAVE REGSITER
	LDA	,U		GET VALUE
	STA	1,U		AND SAVE ONE UP
	JSR	[TEMP2]		DO IT
	LEAX	1,X		NEXT
	PULS	A		RESTORE
	BRA	CEQ5		DO IT AGAIN
* ASSIGNMENT
EQU9	PULS	X,U		RESTORE REGISTERS
	LEAY	1,Y		ADVANCE
	LBSR	SKBKP		SKIP BACK
	LBSR	ASSIGN		PERFORM ASSIGNMENT
	DEC	ASSFLG		SET ASSIGNMENT FLAG
	LBRA	NXTOPR		GET NEXT OPERATOR
* SAVE OUTPUT VECTOR AND CONVERT TO INTEGER (WORDS)
CEQ3	LDX	,S		GET POINTER TO OUTPUT
	PSHS	Y		SAVE POINTER
	LDY	1,X		GET LENGTH
	LEAY	1,Y		ADVANCE FOR LATER DEC
	LDA	#1		GET TYPE
	STA	,X		SAVE TYPE
	LBSR	CALLEN		GET LENGTH
	LEAX	D,X		OFFSET
	CLRA			CLEAR HIGH ORDER BYTE
CEQ6	LEAY	-1,Y		BACKUP
	BEQ	CEQ7		IF END, GO HOME
	LDB	,-U		GET CHAR FROM OUTPUT
	STD	,--X		SAVE IN OUTPUT
	BRA	CEQ6		AND GO AGAIN
CEQ7	PULS	Y		RESTORE Y (AGAIN)
	PULS	X,U		RESTORE REGSITERS
	LBRA	NXTOPR
* CHARACTER EQUALS LOGIC
DCEQU	LDA	,X		GET CHAR
	CMPA	,U		TEST FOR OK
	BNE	DCR0		FALSE
DCR1	LDA	#1		GET ONE
	STA	,U+
	RTS
* CHARACTER NOT EQUALS LOGIC
DCNEQ	LDA	,X		GET CHAR
	CMPA	,U		TEST FOR NOT EQUAL
	BNE	DCR1		TRUE
DCR0	CLRA			FALSE
	STA	,U+
	RTS
* STANDARD DYADIC FUNCTONS
DYFNS	PSHS	X,U		SAVE U REG
	LDU	#DOTAB		POINT TO TABLE
DOD1	TST	,U		CHECK FOR END OF TABLE
	LBEQ	FUNVAL		INVALID, QUIT
	CMPA	,U+		IS THIS IT?
	BEQ	DOD2		YES, GRAB IT
	LEAU	2,U		SKIP TO NEXT
	BRA	DOD1		AND KEEP LOOKING
DOD2	LDU	,U		GET HANDLER ADDRESS
DODYA	LBSR	GETPRM		GET PARAMETER VALUE
	STU	TEMP2		SAVE HANDLER ADDRESS
	LDU	,S		GET OLD OPERAND VALUE
	LDA	,X+		GET TYPE
	LBEQ	CDOM		NOT FOR CHARACTER VALUES
	LDA	,U+		TEST TYPE OF OTHER OPERAND
	LBEQ	CDOM		CHARACTER STILL INVALID
	LDD	,X++		GET LENGTH
	CMPD	,U++		SAME AS OTHER?
	BNE	TSCALE		NO, TRY SCALAR OPERATION
	ADDD	#1		OFFSET FOR ZERO
ZX1	SUBD	#1		REDUCE COUNT
	BEQ	ZX2		END, QUIT
	PSHS	A,B,X		SAVE VALUES
	JSR	[TEMP2]		PERFORM OPERATION
	PULS	A,B,X		RESTORE REGISTERS
	LEAX	2,X		ADVANCE IN NEW
	LEAU	2,U		ADVANCE IN OLD
	BRA	ZX1		GO AGAIN
ZX2	PULS	X,U		RESTORE REGISTERS
	LBRA	NXTOPR
TSCALE	CMPD	#1		TEST FOR SCALER OPERATION
	BNE	TSCAL2		NO, TRY OTHER WAY
	LDD	-2,U		GET LENGTH
	ADDD	#1		ADD FOR LATER DEC
TSL2	SUBD	#1		REDUCE COUNT
	BEQ	ZX2		END, QUIT
	PSHS	A,B,X		SAVE REGISTERS
	JSR	[TEMP2]		PERFORM OPERATION
	PULS	A,B,X		RESTORE REGISTERS
	LEAU	2,U		ADVANCE POINTER
	BRA	TSL2		AND GO IT AGAIN
TSCAL2	LDD	-2,U		GET OTHER LENGTH
	CMPD	#1		TEST FOR LENGTH ONE
	LBNE	CLEN		INVALID LENGTHS
	LDD	-2,X		GET LENGTH OF NEW OPERAND
	STD	-2,U		SET LENGTH OR RESULT
	ADDD	#1		ADVANCE FOR LATER DEC
TSC2	SUBD	#1		REDUCE COUNT
	BEQ	ZX2		END, QUIT
	PSHS	A,B,X		SAVE REGISTERS
	LDD	,U		GET VALUE
	STD	2,U		SAVE LATER
	JSR	[TEMP2]		PERFORM OPERATION
	PULS	A,B,X		RESTORE REGISTERS
	LEAX	2,X		ADVANCE IN NEW
	LEAU	2,U		ADVANCE IN OLD
	BRA	TSC2		AND CONTINUE
*
* DYADIC FUNCTION TABLE
*
DOTAB	FCC	'+'		ADDITION
	FDB	DYADD
	FCC	'-'		SUBTRACTON
	FDB	DYSUB
	FCC	'x'		MULTIPLICATION
	FDB	DYMUL
	FCC	'%'		DIVIDE
	FDB	DYDIV
	FCC	'g'		GREATEST
	FDB	DYCEIL
	FCC	'l'		LEAST
	FDB	DYFLOR
	FCC	'&'		LOGICAL AND
	FDB	DYAND
	FCC	'!'		LOGICAL OR
	FDB	DYOR
	FCC	'm'		MODULUS
	FDB	DYMOD
	FCC	'>'		GREATER THAN
	FDB	DYGT
	FCC	'<'		LESS THAN
	FDB	DYLT
	FCC	'|'		EXCLUSIVE OR
	FDB	DYXOR
	FCB	0
* DYADIC FUNCTION ROUTINES
DYADD	LDD	,X		GET NEW VALUE
	ADDD	,U		ADD OLD VALUE
	STD	,U		SAVE BACK
	RTS
DYSUB	LDD	,X		GET NEW VALUE
	SUBD	,U		SUBTRACT OLD VALUE
	STD	,U		SAVE BACK
	RTS
DYMUL	LDD	,X		GET NEW
	LDX	,U		GET OLD
	LBSR	MULT		DO MULTIPLY
	STD	,U		RESAVE
	RTS
DYDIV	LDD	,U		GET OLD
	LBEQ	CDOM		INDICATE ERROR IF %0
	LDX	,X		GET NEW
	LBSR	DIV		DO DIVISION
	STX	,U		SAVE RESULT
	STD	DIVREM		SAVE REMAINDER
	RTS
DYMOD	LDD	,X		GET NEW VALUE
	LBEQ	CDOM		DIVISION BY ZERO
	LDX	,U		GET OLD VALUE
	LBSR	DIV		DO DIVISION
	STD	,U		SAVE RESULT
	RTS
DYCEIL	LDD	,U		GET OLD VALUE
	CMPD	,X		PERFORM TEST
	BHI	DYRTS		OK, GO HOME
DYSWP	LDD	,X		GET OTHER VALUE
	STD	,U		AND SAVE
DYRTS	RTS
DYFLOR	LDD	,U		GET OLD VALUE
	CMPD	,X		PERFORM TEST
	BLO	DYRTS		OK, GO HOME
	BRA	DYSWP		SWAP
DYAND	LDD	,U		GET OLD
	ANDA	,X		AND HIGH BYTE
	ANDB	1,X		AND LOW BYTE
	STD	,U		RESAVE
	RTS
DYOR	LDD	,U		GET OLD
	ORA	,X		OR HIGH BYTE
	ORB	1,X		OR LOW BYTE
	STD	,U		SAVE RESULT
	RTS
DYXOR	LDD	,U		GET OLD
	EORA	,X		XOR HIGH BYTE
	EORB	1,X		XOR LOW BYTE
	STD	,U		RESAVE
	RTS
DYGT	LDD	,X		GET NEW
	CMPD	,U		TEST AGAINST OLD
	BHI	RET1		ITS TRUE
	BRA	RET0
DYLT	LDD	,X		GET NEW
	CMPD	,U		TEST AGAINST OLD
	BLO	RET1		TRUE
	BRA	RET0		FALES
DYGE	LDD	,X		GET NEW
	CMPD	,U		TEST AGAINST OLD
	BHS	RET1		OK
RET0	CLRB
	BRA	RETX
DYLE	LDD	,X		GET NEW
	CMPD	,U		TEST AGAINST OLD
	BHI	RET0		FALSE
RET1	LDB	#1		TRUE
RETX	CLRA			CLEAR HIGH BYTE,
	STD	,U		SAVE VALUE
	RTS
DYEQ	LDD	,X		GET NEW
	CMPD	,U		TEST AGAINAT OLD
	BEQ	RET1		OK
	BNE	RET0		FALSE
DYNE	LDD	,X		GET NEW
	CMPD	,U		TEST AGAINST OLD
	BEQ	RET0		FALSE
	BRA	RET1		TRUE
* EXECUTE FUNCTION WITH A VALUE
FUNVAL	PULS	X,U		RESTORE STACK
	STX	TEMP		SAVE PARAMETER ADDRESS
	LEAY	1,Y		BACK FOR FUNCTION NAME
	LBSR	LOOKUP		LOOK FOR IT
	CMPA	#2		IS IT A FUNCTION
	LBHS	CSYNT		SYNTAX ERROR
	LBSR	FUNC		PERFORM FUNCTION
	LBRA	NXTOPR		GET NEXT OPERATOR
*
* DISPLAYS VALUE OF A STRUCTURE (X)
*
DISPLY	PSHS	X,U		SAVE VARIABLES
	LDA	,X+		GET TYPE
	BEQ	CHROUT		IT'S CHARACTER DATA
	LDD	,X++		GET LENGTH
	BEQ	NULOUT		NOTHING TO OUTPUT
	PSHS	D		SAVE TEMP
	ADDD	,S		DOUBLE FOR INTEGERS
	LEAU	D,X		SKIP TO END
	PULS	X		GET # ELEMENTS IN X
DIS1	LDD	,--U		GET VALUE
	BSR	DECOUT		OUTPUT
	LBSR	SPACE		DISPLAY SPACE
	LEAX	-1,X		REDUCE COUNT
	BNE	DIS1		AND CONTINUE
	BRA	NULOUT		GO AWAY
CHROUT	LDD	,X++		GET LENGTH
	BEQ	NULOUT		NULL STRING
	LEAU	D,X		SKIP TO END
	TFR	D,X		COPY TO X
DIS2	LDA	,-U		GET CHARACTER
	LBSR	PUTCHR		OUTPUT
	LEAX	-1,X		REDUCE LENGTH,
	BNE	DIS2		KEEP GOING
NULOUT	PULS	X,U,PC		BACK TO WORK
*
* DISPLAY NUMBER (D) IN DECIMAL
*
DECOUT	PSHS	X,Y
	TFR	D,X		COPY
	LDY	#0		START WITH ZERO CHARS
DEC1	LDD	#10		DIVIDE BY 10
	LBSR	DIV		PERFORM DIVISION
	PSHS	B		SAVE IT
	LEAY	1,Y		ADVANCE
	CMPX	#0		OVER YET?
	BNE	DEC1		NO, KEEP GOING
DEC2	PULS	A		GET CHAR BACK
	ORA	#$30		CONVERT TO DISPLAYABLE
	LBSR	PUTCHR		OUTPUT IT
	LEAY	-1,Y		REDUCE COUNT OF CHARACTERS
	BNE	DEC2		AND CONTINUE
	PULS	X,Y,PC
*
* GETS A VALUE FOR THE WORKSPACE (,X)
*
GETPRM	LDX	FREE		POINT TO FREE SPACE
	STY	TXTPTR		SAVE TEXT POSITION
	BSR	GETVAL		GET VALUE
	LBNE	CSYNT		IF NONE, PROCLAIM ERROR
	RTS
GETVAL	PSHS	X,U		SAVE REGSITERS
	LBSR	SKBKP		BACKUP
	CMPA	#')'		EXPRESSION
	BNE	GETV0		NO, CONTINUE
	LBSR	DOEXPR		DO EXPRESSION
	CMPA	#'('		CLOSED PROPERLY?
	LBNE	SYNTAX		INDICATE INVALID
	STX	,S		SAVE OUTPUT ADDRESS
	LBSR	SKBK		BACKUP
	BRA	NV1		GO AGAIN
GETV0	CMPA	#']'		IS IT INDEX?
	LBNE	GETN0		NO, EVERYTHING IS OK
* LOOK UP INDEX VALUE
	LBSR	DOEXPR		GET VALUE
	CMPA	#'['		CLOSE PROPERLY
	LBNE	SYNTAX		INVALID SYNTAX
	LDA	,X		GET TYPE
	CMPA	#1		IS IT INTEGER?
	LBNE	DOMAIN		INDICATE DOMAIN ERROR
	LBSR	SKBK		BACKUP
	STX	,S		SAVE POINTER TO ENTRY
	LDD	TEMP5		GET BUFFER ADDRESS
	SUBD	BUFSIZ		ALLOCATE ANOTHER BUFFER
	STD	TEMP5		RESAVE
	LBSR	GETPRM		GET VALUE
	LDD	TEMP5		GET BUFFER ADDRESS
	ADDD	BUFSIZ		RELEASE BUFFER
	STD	TEMP5		RESAVE
	LDU	,S		GET ORIG. PARM BACK
	LDD	1,X		GET LENGTH
	SUBD	#1		CONVERT TO OFFSET FROM ZERO
	STD	TEMP4		SAVE FOR REF
	LDA	,X		GET ARG. TYPE
	LEAX	3,X		SKIP TO DATA
	STA	,U+		SET DEST TYPE
	BEQ	CHRI		CHARACTER INDEX
	LDD	,U++		GET LENGTH
NUMI	PSHS	A,B		SAVE
	LDD	,U		GET INDEX VALUE
	SUBD	ORIGIN		SUBTRACT ORIGIN VALUE
	PSHS	A,B		SAVE VALUE ON STACK
	LDD	TEMP4		GET VALUE
	SUBD	,S++		CONVERT TO PROPER OFFSET
	LBCS	INDEX		INDICATE INDEX ERROR
	LSLB
	ROLA			DOUBLE FOR TWO BYTE ENTRIES
	LDD	D,X		GET OPERAND
	STD	,U++		SAVE IN OUTPUT
	PULS	A,B		GET LENGTH BACK
	SUBD	#1		REDUCE
	BNE	NUMI		AND KEEP GOING
NV1	ORCC	#4		SET Z FLAG
	PULS	X,U,PC		GO HOME
CHRI	LDD	,U++		SAVE VALUE
	STY	TXTPTR		SAVE TEXT POINTER
	TFR	U,Y		POINT TO CHARACTER SPACE
CHRI1	PSHS	A,B		SAVE
	LDD	,U++		GET INDEX VALUE
	SUBD	ORIGIN		SUBTRACT ORIGIN VALUE
	PSHS	A,B		SAVE VALUE ON STACK
	LDD	TEMP4		GET VALUE
	SUBD	,S++		CONVERT TO PROPER OFFSET
	BCS	CIDX		INDICATE INDEX ERROR
	LDA	D,X		GET OPERAND
	STA	,Y+		SAVE IN OUTPUT
	PULS	A,B		GET LENGTH BACK
	SUBD	#1		REDUCE
	BNE	CHRI1		AND KEEP GOING
	LDY	TXTPTR		GI IT AGAIN
	BRA	NV1
CIDX	LDY	TXTPTR		GET TEXT POINTER AGAIN
	LBRA	INDEX		GET UPSET
* TEST FOR NUMBER
GETN0	LBSR	VALNUM		IS IT A NUMBER?
	BNE	GETV1		NO, TRY STRING
	LDA	#1		INDICATE ONE VARIABLE
	STA	,X		SET TYPE
	LEAX	3,X		SKIP POSITION
	LDU	#0		START WITH ZERO ELEMENTS
GETN1	LBSR	SKBKP		LOOK FOR NUMBER
	LBSR	VALNUM		VALID NUMBER?
	BNE	GETV9		LAST NUMBER
	LEAU	1,U		ADVANCE
	LBSR	GETDEC		GET A NUMBER
	STD	,X++		SAVE VALUE
	BRA	GETN1		AND TRY AGAIN
GETV1	CMPA	#$27		IS IT A CHARACTER VALUE?
	BNE	GETV2		NO, TRY NEXT
* GETS A CHARACTER VALUE FOR THE WORKSPACE
	CLR	,X		INDICATE CHARACTER DATA
	LEAX	3,X		SKIP FOR NOW
	LDU	#0		START WITH ZERO CHARACTER
GETC2	LDA	,-Y		GET NEXT CHARACTER
	CMPA	#$27		CLOSING QUOTE?
	BEQ	GETC3		IF SO, QUIT
	CMPA	#$0D		END OF LINE?
	LBEQ	SYNTAX		INDICATE ERROR
GETC5	LEAU	1,U		INC. NUMBER OF CHARACTERS IN STRING
	STA	,X+		SAVE IN OUTPUT VALUE
	BRA	GETC2		NO TRY FOR ANOTHER
GETC3	LDA	-1,Y		GET PRECEDING CHAR
	CMPA	#$27		QUOTE?
	BNE	GETC4		NO, TERMINATE
	LDA	,-Y		GET CHARACTER
	BRA	GETC5
GETC4	LBSR	SKBK		ADVANCE BACKWARDS
GETV9	LDX	,S		GET OFFSET
	STU	1,X		SAVE SIZE
	ORCC	#4		SET Z FLAG
	PULS	X,U,PC		BACKUP AND RETURN
* TEST FOR SYSTEM VARIABLE
GETV2	CMPA	#'$'		SYS VAR?
	BNE	GETV3		NO, TRY SYMBOL
	LDB	#1		GET TYPE, INTEGER
	STB	,X+		SAVE IN RAM
	CLRA			SET LENGTH TO 1
	STD	,X++		SAVE LENGTH
	LDA	,-Y		GET SYMBOL LENGTH
	CMPA	#'L'		IS IT LINE NUMBER?
	BNE	SYS1		NO, TRY ORIGIN
	LDD	LINCT		GET COUNTER
	BRA	SYS9		AND EXIT WITH IT
SYS1	CMPA	#'O'		ORIGIN?
	BNE	SYS2		NO, TRY WSSIZE.
	LDD	ORIGIN		GET ORIGIN VALUE
	BRA	SYS9		AND EXIT
SYS2	CMPA	#'W'		IS IT WORKSPACE SIZE?
	BNE	SYS3		NO, TRY DIV REM
	LDD	TEMP5		GET FREE ADDRESS
	SUBD	FREE		CONVERT TO SIMPLE OFFSET
	BRA	SYS9		END EXIT
SYS3	CMPA	#'R'		REMAINDER?
	BNE	SYS4		NO, TRY SEED
	LDD	DIVREM		GET REMANDER
	BRA	SYS9		AND EXIT
SYS4	CMPA	#'S'		SEED?
	BNE	ATOM		NO, TRY ATOMIC VECTOR
	LDD	SEED		GET SEED VALUE
	BRA	SYS9		AND SAVE
ATOM	CMPA	#'C'		CHARACTER STRING?
	BNE	SY5		NO, TRY NEXT
	CLR	-3,X		INDICATE CHARACTER
	LDD	#256		LENGTH OF IT
	STD	-2,X		SET IT UP
	CLRA			START WITH NULL
AV1	DECA			BACKUP THROUGH CHARACTER SET
	STA	,X+		SAVE IN VECTOR
	BNE	AV1		KEEP GOING
	BRA	SYSX		GO  HOME
SY5	CMPA	#'B'		BUFFER SIZE?
	BNE	SYSPRM		NO, TRY PARM
	LDD	BUFSIZ		GET BUFFER SIZE
SYS9	STD	,X		SAVE VALUE
SYSX	LBSR	SKBK		SKIP BACK TO NEXT
	ORCC	#4		SET Z FLAG
	PULS	X,U,PC		AND GO HOME
* LOOK FOR SYMBOL IN TABLE
GETV3	LBSR	VALSYM		IS IT A SYMBOL
	BNE	GETV4		NOT VALID
	LDD	#IOTA0		DEFAULT PARAMETER
	STD	TEMP		SAVE
	LBSR	LOOKUP		LOOK UP VALUE
	LBNE	VALUE		INDICATE VALUE ERROR
	CMPA	#2		IS IT A VARIABLE
	BNE	GETV5		NO, TRY LABEL
	LDX	B,X		POINT TO VARIABLE ENTRY
	BRA	GETV6		GO FOR IT
GETV5	CMPA	#3		IS IT A LABEL?
	BNE	GETV7		NO, TRY.
	LDD	B,X		GET VALUE
	LDX	,S		GET STACK VALUE
	STD	3,X		SAVE IT
	LDB	#1		GET TYPE
	CLRA			ZERO HIGH BYTE
	STB	,X		SAVE TYPE
	STD	1,X		SAVE LENGTH
	BRA	GETV6
GETV7	LBSR	FUNC		CALL FUNCTION
GETV6	LEAS	2,S		SKIP X VALUE FROM STACK
	ORCC	#4		SET Z FLAG
	PULS	U,PC		AND GO HOME
GETV4	ANDCC	#$FB		CLEAR Z FLAG
	PULS	X,U,PC		AND RETURN
* 'P$' SYSTEM VARIABLE
SYSPRM	CMPA	#'P'		IS IT PARAMETER
	BNE	KREAD		NO, TRY TO READ TERMINAL
	LBSR	SKBK		BACKUP
	LDX	PARM		GET PARAMETER POINTER
	BRA	GETV6		RETURN
* READ A SINGLE KEYBOARD KEY
KREAD	CMPA	#'K'		READ KEYBOARD?
	BNE	INTER		NO, TRY READ LINE
	CLR	-3,X		SET TYPE TO CHARACTER
	LDD	#1		GET LENGTH OF ONE
	STD	-2,X		SAVE
	LBSR	GETCHR		READ A CHARACTER
	STA	,X		SAVE IT
SYSX1	BRA	SYSX		GO HOME
* READ LINE FROM TERMINAL
INTER	CMPA	#'F'		FORMATTED INPUT?
	BNE	INNUM		NO, TRY FOR NUMERIC INPUT
	PSHS	Y		SAVE VARIABLE POINTER
	LDY	TEMP5		GET BUFFER ADDRESS
	LEAY	-128,Y		BACKUP TO FREE RAM
	LBSR	GETLIN		READ IT
	DECB			BACKUP
	CLRA			SET HIGH BYTE TO ZERO
	STA	-3,X		SET TYPE TO CHARACTER
	STD	-2,X		SET LENGTH
	BEQ	INTER2		ZERO LENGTH
INTER1	DECB			BACKUP
	LDA	B,Y		GET CHARACTER FROM BUFFER
	STA	,X+		SAVE IN OUTPUT
	TSTB			BACKUP
	BNE	INTER1		SAVE IT ALL
INTER2	PULS	Y		RESTORE TEXT POINTER
	BRA	SYSX1		AND GO HOME
INNUM	CMPA	#'T'		TERMINAL INP?
	LBNE	SYNTAX		NO, GET UPSET
INN1	LDD	RAMTOP		GET TOP OF RAM
	PSHS	A,B,Y		SAVE
	LDY	NAMPTR		POINT TO NAME
	LDD	LINCT		GET LINE COUNTER
	PSHS	A,B,Y		SAVE
	LDY	GOTO		GET GOTO POINTER
	LDD	PARM		GET PARAMETERS
	PSHS	A,B,Y		SAVE
	LDY	SAVSTK		SAVED STACK POINTER
	LDD	INPSTK		GET INPUT STACK
	PSHS	A,B,Y		SAVE
	STS	INPSTK		SAVE OUR STACK POINTER
	LDD	TEMP5		GET BUFFER ADDRESS
	STD	RAMTOP		SAVE IT BACK
INN2	LDA	#'?'		GET PROMPT
	LBSR	PUTCHR		DISPLAY
	LDY	TEMP5		POINT TO RAM ADDRESS
	LEAY	-128,Y		BACKUP FOR SOME BUFFER SPACE
	STY	TEMP5		RESERVE THIS BUFFER
	LBSR	GETLIN		GET A LINE
	LBSR	SKP		ADVANCE
	CMPA	#$0D		CR?
	BEQ	INN2		IF SO, GO AGAIN
	LDA	#$0D		GET CR
	STA	-1,Y		SAVE
	LBSR	EXPR		DO EXPRESSION
INNP3	LDD	RAMTOP		GET BUFFER ADRESS
	STD	TEMP5		RESAVE
	LDS	INPSTK		GET INPUT STACK
	PULS	A,B,Y		GET VALUES BACK
	STD	INPSTK		SAVE INPUT FLAG
	STY	SAVSTK		RESAVE STACK
	PULS	A,B,Y		GET MORE
	STD	PARM		SAVE PARM POINTER
	STY	GOTO		SAVE GOTO FLAG
	PULS	A,B,Y		GET LINCT AND NAMPTR
	STD	LINCT		SAVE LINE COUNT
	STY	NAMPTR		RESAVE
	PULS	A,B,Y		GET TOP OF RAM
	STD	RAMTOP		AND RESAVE
	TST	ERRFLG		DID AN ERROR OCCUR?
	BNE	INN1		IF SO, GO AGAIN
	LBSR	SKBK		BACKUP
	LBRA	GETV6		AND GO HOME
*
* ASSIGN VALUE(X) TO VARIABLE
*
ASSIGN	PSHS	X,U		SAVE VALUE
	STY	TEMP3		SAVE FOR LATER
	LDA	,Y		GET VALUE
	CMPA	#']'		INDEXED ASSIGNMENT
	LBEQ	IASS		INDICATE SO
	CMPA	#'$'		IS IT A SYSTEM VARIABLE?
	BNE	ASI1		NO, NORMAL ASSIGNMENT
	LDA	,-Y		GET NEXT CHARACTER
	CMPA	#'O'		SETORIGIN?
	BNE	ASN1		NO, TRY SEED
	LDU	#ORIGIN		SAVE VALUE
	BRA	ASN9		AND QUIT
ASN1	CMPA	#'C'		CHARACTER?
	BEQ	ASN8		PERFORM DUMP
	CMPA	#'S'		SET RANDOM SEED?
	BNE	ASN2		NO, TRY NEXT
	LDU	#SEED		SAVE RANDOM SEED
	BRA	ASN9		SAVE VALUE
ASN2	CMPA	#'B'		BUFFER SIZE
	BNE	LGOTO		TRY GOTO LINE
	LDU	#BUFSIZ		POINT TO IT
ASN9	LDA	,X		GET TYPE
	LBEQ	DOMAIN		INVALID
	LDD	1,X		GET LENGTH
ASN89	CMPD	#1		SINGLE ELEMENT?
	LBNE	LENGTH		NO, IT'S INVALID
	LDD	3,X		GET VALUE
	STD	,U		SAVE IN DEST
ASN8	LBSR	SKBK		BACKUP
	PULS	X,U,PC		RETURN
* BRANCH BY CHANGEING VALUE OF 'L$'
LGOTO	CMPA	#'L'		IS IT 'L'$
	BNE	TEROUT		NO, SAY ERROR
	LDA	,X		GET TYPE
	LBEQ	DOMAIN		INVALID
	LDD	1,X		GET LENGTH
	BEQ	ASN8		IF ZERO, IGNORE
	LDU	#GOTO
	BRA	ASN89
* DISPLAY VALUE ON TERMINAL
TEROUT	CMPA	#'T'		TERMINAL I/O?
	BNE	FRMOUT		NO, TRY FORMATTED
	LBSR	DISPLY		DISPLAY IT
	LBSR	LFCR		NEW LINE
	BRA	ASN8		GO HOME
FRMOUT	CMPA	#'F'		FORMATTED OUTPUT?
	LBNE	SYNTAX		NO, GET UPSET
	LBSR	DISPLY		OUTPUT IT
	BRA	ASN8		AND GO IT AGAIN
* LOOK UP SYMBOL VALUE
ASI1	LBSR	VALSYM		IS IT A VALID SYMBOL NAME
	LBNE	SYNTAX		NO, GET UPSET
	LBSR	CALLEN		GET LENGTH
	PSHS	A,B		SAVE LENGTH
	LBSR	LOOKUP		LOOK FOR DATA
	BNE	NEWV		CREATE NEW VARIABLE
	CMPA	#2		IS IT A VARIABLE
	LBNE	SYNTAX		INDICATE INVALID SYNTAX
	STX	TEMP4		SAVE FOR LATER
	LDX	B,X		GET ADDRESS OF VARIABLE
	LBSR	CALLEN		DO THEY NEED SAME SPACE
	CMPD	,S		ARE THEY SAME
	BEQ	ASI2		IF SO, NO NEED TO CHANGE
	LDX	TEMP4		SYMBOL TABLE ENTRY BACK
	LBSR	ERASYM		ERASE SYMBOL
NEWV	LDA	#2		GET TYPE
	LDY	TEMP3		POINT TO NAME
	LBSR	CRESYM		CREATE SYMBOL
	PULS	A,B		GET LENGTH
	LDU	,X		GET ADDRESS OF SYMBOL
	LDX	,S		GET SYMBOL VALUE
	PSHS	Y		SAVE POINTER
	TFR	D,Y		COPY TO Y
ASI3	LDA	,X+		GET BYTE FROM STRUCTURE
	STA	,U+		RESAVE
	LEAY	-1,Y		BACKUP
	BNE	ASI3		KEEP SAVEING
	PULS	Y		RESTORE Y
	STU	FREE		SAVE FREE VALUE
	PULS	X,U,PC
ASI2	PULS	A,B		GET COUNT
	LDU	,S		GET OLD VALUE ADDRESS
	PSHS	Y		SAVE POINTR
	TFR	D,Y		COPY
ASI4	LDA	,U+		GET DATA FROM OLD
	STA	,X+		SAVE IN NEW
	LEAY	-1,Y		BACKUP
	BNE	ASI4		INSERT
	PULS	Y		RESTORE POINTER
	PULS	X,U,PC		COND CONTINUE
* INDEXED ASSIGNEMENT TO AN EXISTING VARIABLE
IASS	LBSR	DOEXPR		GET ASSIGNMENT VALUE
	CMPA	#'['		TEST FOR PROPER TERMINATION
	LBNE	SYNTAX		INDICATE INVALID
	DEC	ASSFLG		SET LAST OPERATOR
	LDA	,X+		GET TYPE OF INDEX VALUE
	CMPA	#1		IS IT AN INTEGER VALUE
	LBNE	DOMAIN		IF NOT, SAY SO
	PSHS	X		SAVE POINTER TO VALUE
	LBSR	SKBK		BACKUP AGAIN
	LBSR	LOOKUP		FIND VARIABLE
	LBNE	VALUE		IT'S BAD
	CMPA	#2		IS IT A VARIABLE?
	LBNE	SYNTAX		NO, GIVE UP
	LDX	B,X		POINT TO VARIABLE ADDRESS
	PULS	U		GET INDEX BACK
	STY	TXTPTR		SAVE TEXT POINTER
	LDY	,S		GET SOURCE VALUE
	LDA	,X		GET TYPE OF VARIABLE
	CMPA	,Y+		SAME AS TYPE OF ARGUMENT
	BNE	CDOM		NO, COMPLAIN
	CLR	TEMP		INDICATE SINGLE MODE
	LDD	,Y++		GET LENGTH OF SOURCE
	CMPD	#1		LENGTH ONE IS SPECIAL CASE
	BEQ	IDA0		IF SO, IT'S OK
	CMPD	,U		SAME SIZE AS INDEX
	BNE	CLEN		INDICATE LENGTH ERROR
	DEC	TEMP		INDICATE NORMAL MODE
IDA0	LDD	,U++		GET LENGTH OF INDEX
	BEQ	CLEN		INDICATE LENGTH ERROR IS ZERO LENGTH INDEX
IDA1	PSHS	A,B		SAVE IT
	LDD	,U++		GET INDEX VALUE
	SUBD	ORIGIN		SET ORIGIN VALUE
	PSHS	A,B		SAVE IN STACK
	LDD	1,X		GET LENGTH OF DEST VARIABLE
	SUBD	#1		CONVERT TO ZERO OFFSET
	SUBD	,S++		CONVERT OFFSET
	LBCS	CIDX		INDEX ERROR IF OVER
	TST	,X		CHARACTER INFO?
	BEQ	IDA2		IF SO, DON'T DOUBLE ADDRESS
	LSLB
	ROLA			DOUBLE FOR TWO BYTE ENTRIES
	PSHS	U		SAVE Y POINTER
	ADDD	#3		OFFSET FOR TYPE AND LENGTH
	LEAU	D,X		POINT TO OFFSET
	LDD	,Y++		GET VALUE FROM SOURCE
	STD	,U		SAVE IN DATA
	LDA	TEMP		ADVANCE?
	BNE	IDA3
	LEAY	-2,Y		BACKUP
	BRA	IDA3		END
IDA2	PSHS	U		SAVE POINTER
	ADDD	#3		OFFSET FOR TYPE AND LENGTH
	LEAU	D,X		OFFSET TO AREA
	LDA	,Y+		GET CHARACTER
	STA	,U		SAVE BACK
	TST	TEMP		NORMAL?
	BNE	IDA3		YES, GOT FOR IT
	LEAY	-1,Y		BACKUP
IDA3	PULS	U		RESTORE POINTER
	PULS	A,B		RESTORE COUNT
	SUBD	#1		OVER YET?
	BNE	IDA1		NO, GO AGAIN
	LDY	TXTPTR		RESTORE TEXT POINTER
	PULS	X,U,PC		GO HOME
CLEN	LDY	TXTPTR
	LBRA	LENGTH
CDOM	LDY	TXTPTR
	LBRA	DOMAIN
*
* RETURN LENGTH (IN BYTES) OF STRUCTURE(X)
*
CALLEN	LDD	1,X		GET SHAPE
	TST	,X		IS IT CHARACTER
	BEQ	CALL1		YES, DON'T DOUBLE
	LSLB
	ROLA			DOUBLE FOR TWO BYTE ENTRIES
CALL1	ADDD	#3		AND IN LENGTH, AND TYPE DATA
	RTS
*
* INSURE DATA IS IN WORKSPACE
*
MVWRK	PSHS	Y,U		SAVE POINTER
	CMPX	TEMP5		IS IT IN WORKSPACE?
	BEQ	MVRTS		ALL IS OK
	LDU	TEMP5		POINT
	LDA	,X+		GET POINTER
	STA	,U+		SAVE
	LDY	,X++		GET LENGTH
	STY	,U++		SAVE
	TSTA			CHARACTER MOVE?
	BEQ	CHRMV		IF SO, SPECIAL
MV1	CMPY	#0		ZERO LENGTH?
	BEQ	MVRTS		IF SO, QUIT
	LEAY	-1,Y		BACKUP
	LDD	,X++		GET FROM SOURCE
	STD	,U++		SAVE
	BRA	MV1		OK
CHRMV	CMPY	#0		ZERO LENGTH?
	BEQ	MVRTS		IF SO, QUIT
	LEAY	-1,Y		BACKUP
	LDD	,X+		GET CHAR
	STD	,U+		SAVE CHAR
	BRA	CHRMV		OK
MVRTS	LDX	TEMP5		POINT TO SPACE
	PULS	Y,U,PC		HOME
*
* LOOK UP AND EXECUTE COMMAND
*
CLOOK	PSHS	Y		SAVE COMMAND POINTER
CL5	LDA	,X+		GET CHARACTER FROM TABLE
	BMI	CCHK		LAST ONE, CHECK IT
	CMPA	,Y+		DOES IT MATCH?
	BEQ	CL5		YES, KEEP LOOKING
CL2	LDA	,X+		GET NEXT
	BPL	CL2		LOOK FOR END
CL3	LEAX	2,X		SKIP ADDRESS
	PULS	Y		RESTORE POINTER
	BRA	CLOOK		AND GO AGAIN
CCHK	ANDA	#$7F		REMOVE HIGH BIT
	BEQ	CL4		END OF TABLE
	CMPA	,Y+		IS IT SAME AS FROM BUFFER?
	BNE	CL3		NO, GO AGAIN
CL4	LEAS	2,S		CLEAN UP STACK
	LBSR	SKP		ADVANCE TO PARAMETERS
	JMP	[,X]		EXECUTE CODE
*
* ERROR MESSAGES
*
SYMSG	FCCZ	'SYNTAX'
VALMSG	FCCZ	'VALUE'
DOMMSG	FCCZ	'DOMAIN'
LENMSG	FCCZ	'LENGTH'
INDMSG	FCCZ	'INDEX'
BRKMSG	FCC	'INTERRUPT'
	FCB	$0D
*
* ERROR HANDLERS
*
REBRK	LDD	RAMTOP		GET BUFFER ADRESS
	STD	TEMP5		RESAVE
	LDS	INPSTK		GET INPUT STACK
	PULS	A,B,Y		GET VALUES BACK
	STD	INPSTK		SAVE INPUT FLAG
	STY	SAVSTK		RESAVE STACK
	PULS	A,B,Y		GET MORE
	STD	PARM		SAVE PARM POINTER
	STY	GOTO		SAVE GOTO FLAG
	PULS	A,B,Y		GET LINCT AND NAMPTR
	STD	LINCT		SAVE LINE COUNT
	STY	NAMPTR		RESAVE
	PULS	A,B,Y		GET TOP OF RAM
	STD	RAMTOP		AND RESAVE
BREAK	LDD	INPSTK		ARE WE INPUTTING?
	BNE	REBRK		YES, FIX IT UP
	LDA	EXEC		EXECUTING FUNCTION?
	BEQ	BRK0		OK TO DISPLAY
	LDA	[NAMPTR]	GET TYPE BITS
	ANDA	#$20		IS IT LOCKED
	BEQ	BRK0		NO, IT'S OK
	LBSR	RELEAS		RELEASE THIS ONE
	BRA	BREAK		ALWAYS A DOMAIN ERROR
BRK0	LDX	#BRKMSG		DISPLAY
	LBSR	OULI		DISPLAY
	BRA	ERR0		AND CONTINUE
* WORKSACE IS FULL
WSFUL	LBSR	SYSMSG		DISPLAY MESSAGE
	FCCZ	'WS FULL'
	BRA	ERR0		CONTINUE
SYNTAX	LDX	#SYMSG
	BRA	ERROR
VALUE	LDX	#VALMSG
	BRA	ERROR
DOMAIN	LDX	#DOMMSG
	BRA	ERROR
LENGTH	LDX	#LENMSG
	BRA	ERROR
INDEX	LDX	#INDMSG
ERROR	LDA	EXEC		EXECUTING FUNCTION?
	BEQ	OKDISP		OK TO DISPLAY
	LDA	[NAMPTR]	GET TYPE BITS
	ANDA	#$20		IS IT LOCKED
	BEQ	OKDISP		NO, IT'S OK
	LDD	INPSTK		INPUTTING?
	BNE	OKDISP		CONTINUE
	LBSR	RELEAS		RELEASE THIS ONE
	BRA	DOMAIN		ALWAYS A DOMAIN ERROR
OKDISP	LBSR	OULI		DISPLAY MESSAGE
	LBSR	SYSMSG
	FCCZ	' ERROR'
ERR0	LDA	EXEC		EXECUTING FUNCTION?
	BEQ	ERR01		NO
	LDX	NAMPTR		POINT TO ENTRY
	LDD	LINCT		GET LINE COUNTER
	LBSR	DSPNAM		DISPLAY IT
	LBSR	LFCR		NEW LINE
	LDD	LINCT		LINE ZERO?
	BEQ	ERR9
ERR01	CLRB			START WITH ZERO OFFSET
ERR1	LDA	,Y		GET CHARACTER FROM Y REGISTER
	CMPA	#$0D		END OF LINE?
	BEQ	ERR5		IF SO, TOO BAD
	INCB			ADVANCE
	LEAY	-1,Y		AND BACKUP IN LINE
	BRA	ERR1		CONTINUE
ERR5	LEAY	1,Y		BACK TO BEFORE CR
ERR2	LDA	,Y+		GET CHARACTER
	LBSR	PUTCHR		DISPLAY
	CMPA	#$0A		END OF LINE?
	BNE	ERR2		NO, KEEP GOING
	TSTB			CHECK FOR OVER
	BEQ	ERR4		ALL DONE
ERR3	DECB			REDUCE COUNT
	BEQ	ERR4		OK
	LBSR	SPACE		SPACE OVER
	BRA	ERR3		TILL WE ARE UNDER IT
ERR4	LDA	#'^'		GET ERROR MARK
	LBSR	PUTCHR		DISPLAY
	LBSR	LFCR		NEW LINE
ERR9	DEC	ERRFLG		INDICATE ERROR HAPPENED
	LDD	INPSTK		ARE WE INPUTTING
	LBNE	INNP3		IF SO, RECOVER
	LBRA	CMD		ENTER COMMAND MODE
* DISPLAY NAME OF FUNCTION, A,B= LINE NUMBER, X= NAME POINTER
DSPNAM	PSHS	A,B		SAVE REGS
	LDB	,X+		GET LENGTH OF NAME
	ANDB	#$1F		MASKOFF SHIT
ERRP	LDA	B,X		GET CHARACTER
	LBSR	PUTCHR		DISPLAY
	DECB			REDUCE COUNT
	BNE	ERRP		KEEP GOING
	LDA	#'['		START
	LBSR	PUTCHR		DISPLAY
	PULS	A,B		RESTORE IT
	LBSR	DECOUT		DISPLAY
	LDA	#']'		CLOSING BRACE
	LBRA	PUTCHR		DISPLAY
*
* START A FUNCTION
*
FUNC	PSHS	Y		SAVE TEXT POINTER
	LDY	RAMTOP		GET TOP OF FREE RAM
	PSHS	Y		RESAVE
	LDY	NAMPTR		GET NAME POINTER
	PSHS	Y		SAVE
	STX	NAMPTR		SAVE OUR NAME
	LDY	B,X		GET TEXT POINTER
	LDX	LINCT		GET LINE COUNTER
	LDD	GOTO		GET GOTO POINTER
	PSHS	A,B,X		SAVE
	LDX	PARM		SAVE OUT GOTO VALUE
	LDD	SAVSTK		GET SAVED STACK VALUE
	PSHS	A,B,X		SAVE
	LDD	TEMP		GET TEMPORARY STORAGE
	STD	PARM		SAVE PARAMETER
	CLRA			CLEAR IT
	CLRB			START WITH LINE #0
	STD	LINCT		SET LINE NUMBER
	STD	GOTO		SAVE WHERE WE WANT TO GO
	PSHS	Y		SAVE POINTER TO LOCAL SYMBOLS
	INC	LEVEL		DOWN ANOTHER LEVEL
	INC	EXEC		EXECUTING
	STS	SAVSTK		SAVE STACK
	LDD	TEMP5		GET TOP OF FREE RAM
	STD	RAMTOP		SET IT UP
* FIX UP FOR LOCAL SYMBOLS
LCVAR	LBSR	SKIP		ADVANCE TO NEXT
	CMPA	#$0D		END OF LINE?
	BEQ	FNGO		GO AHEAD
	CMPA	#';'		SEMI?
	LBNE	SYNTAX		INDICATE SYNTAX ERROR
	LBSR	SFSYM		ADVANCE
	PSHS	Y		SAVE
	LEAY	-1,Y		BACK TO SYMBOL
	LBSR	LOOKUP		LOOK FOR IT
	BNE	LCV1		DON'T ZAP IF NOT THERE
	LDA	LEVEL		GET OUR LEVEL
	STA	1,X		INDICATE THAT IT IS NESTED
LCV1	PULS	Y		RESTORE Y REG
	BRA	LCVAR		AND GO AGAIN
* CREATE LABEL ENTRIES IN SYMBOL TABLE
FNGO	LDU	#0
FUNGT	LDA	,Y+		GET CHAR FROM LINE
	BMI	FNGOX		END OF FILE, QUIT
	CMPA	#$0D		LOOK FOR CARRAGE RETURN
	BNE	FUNGT		LOOK TILL WE FIND
	LEAU	1,U		ADVANCE
	LBSR	SFSYM		SKIP FORWARD
	BEQ	FUNGT		NO SYMBOL, GET UPSET
	CMPA	#':'		LABEL?
	BNE	FUNGT		NO, SKIP IT
	PSHS	Y		SAVE POINTER
	LEAY	-1,Y		BACKUP
	LBSR	LOOKUP		DOES IT EXIST?
	BNE	FNGOZ		NO, DON'T SAVE IT
	LDA	LEVEL		GET LEVEL
	STA	1,X		SAVE IT
FNGOZ	LDY	,S		GET POINTER BACK
	LEAY	-1,Y		BACKUP
	LDA	#3		INDICATE LABEL
	LBSR	CRESYM		SAVE IT
	STU	,X		SAVE LINE NUMBER
	PULS	Y		RESTORE Y
	BRA	FUNGT		CONTINUE
FNGOX	LDX	#IOTA0		POINT TO EMPTY VECTOR FOR DEFAULT RETURN
	LDY	,S		GET TEXT POINTER
* START IT UP
FNXLIN	LDA	,Y+		ADVANCE TO NEXT
	CMPA	#$0D		END OF LINE?
	BNE	FNXLIN		CONTINUE
	LDD	GOTO		IS THIS WEHERE WE WANT TO GO?
	BEQ	GOTOK		GOTO IS OK
	PSHS	X		SAVE X
	LDX	2,S		GET TEXT ADRESS
	LBSR	FNDL1		LOCATE THE LINE
	TFR	X,Y		COPY BACK
	PULS	X		RESTORE X
	LDD	TEMP3		GET LINE NUMBER
	BRA	GOT1
GOTOK	LDD	LINCT		GET LINE COUNTER
	ADDD	#1		ADVANCE
GOT1	STD	LINCT		RESAVE
	CLRA
	CLRB
	STD	GOTO		RESET GOTO FLAG
	LDA	,Y		GET NEXT CHARACTER
	CMPA	#$FF		END OF FUNCTION?
	BEQ	EFUNC		NO, GO AGAIN
	CMPA	#'*'		COMMENT?
	BEQ	FNXLIN		GO TO NEXT LINE
	SSR	35		LOOK FOR KEYBOARD KEY
	CMPA	#$03		CONTROL C?
	LBEQ	BREAK		INTERRUPT PROGRAM
NOINT1	LBSR	EXPR		EXECUTE
	BRA	FNXLIN
* END OF A FUNCTION
EFUNC	PULS	Y		GET POINTER BACK
	PSHS	X		SAVE IT
EFUN1	LBSR	SKIP		LOOK FOR IT
	CMPA	#$0D		END?
	BEQ	EFUPOT		IF SO, EXIT
	LBSR	SFSYM		SKIP TO END
	PSHS	Y		SAVE IT
	LEAY	-1,Y		BACKUP
	LBSR	LOOKUP		LOOK FOR IT
	BNE	EFUN3		NOT FOUND
	LBSR	ERASYM		ERASE IT
EFUN3	PULS	Y		RESTORE POINTER
	BRA	EFUN1		AND GO AGAIN
EFUPOT	LDA	,Y+		GET CHAR
	BMI	EFUN2		END, QUIT
	CMPA	#$0D		END OF LINE?
	BNE	EFUPOT		GO
	LBSR	SFSYM		SCAN FOR SYMBOL
	BEQ	EFUPOT		NONE, SKIP IT
	CMPA	#':'		IS IT LOCAL LABEL?
	BNE	EFUPOT		NO, SKIP IT
	PSHS	Y		SAVE IT
	LEAY	-1,Y		BACKUP
	LBSR	LOOKUP		LOOK FOR IT
	BNE	NOFUNE		DON'T ERASE
	LBSR	ERASYM		ERASE IT
NOFUNE	PULS	Y		RESTORE Y
	BRA	EFUPOT		CONTINUE
* REPLACE SMUDGED VARIABLES
EFUN2	LDX	#SYMTAB		POINT TO SYMBOL TABLE
	LDA	LEVEL		GET OUR LEVEL
EFUN4	LDB	,X		GET TYPE BYTE
	ANDB	#$1F		MASK GARBAGE
	BEQ	EFUN5		END OF TABLE
	CMPA	1,X		IS THIS ONE WE NESTED?
	BNE	EFUN6		NO, SKIP IT
	CLR	1,X		RELEASE IT
EFUN6	ADDB	#4		ADVANCE EXTRA BYTES
	ABX			SKIP AHEAD
	BRA	EFUN4		GO IT AGAIN
EFUN5	PULS	X		RESTORE REGISTERS
	PULS	A,B,Y		RESTORE PARAMETER ADDRESS
	STD	SAVSTK		REPLACE SAVED STACK POINTER
	STY	PARM		SET PARAMETER VALUE
	PULS	A,B,Y		RESTORE NAME POINTER
	STD	GOTO		SAVE
	STY	LINCT		SAVE LINE COUNTER
	PULS	A,B,Y		RESTORE VARIABLES
	STD	NAMPTR		RESET LINE COUNTER
	STY	RAMTOP		SET BUFFER ADDRESS
	DEC	LEVEL		RESET MODE
	DEC	EXEC		RELEASE EXECUTION FLAG
	CLR	ASSFLG		NO ASSIGNMENT
	PULS	Y,PC		BACKUP AND RETURN
*
* SYSTEM COMMAND DEFINTIONS
*
* CONTINUE COMMAND
CONCMD	LDY	#CONTIN		POINT AT FILENAME
	LBSR	SAV5		PERFORM SAVE
* ')OFF' COMMAND
OFF	CLRA			INDICATE MESSAGES
	SSR	104		WITH DOS COMMAND
	CLRA			SET ZERO RC
	SSR	0		RETURN TO OS
* ')LBLS' COMMAND
LBLS	LDA	#$60		GET TYPE
	STA	TEMP		SAVE IT
	BRA	FNST1		SAVE SINGLE TYPE LIST
* ')VARS' COMMAND
VARS	LDA	#$40		INDICATE LOOKING FOR VARIABLES
	STA	TEMP		SET INDICATOR
FNST1	LDA	#$E0		SET MASK
	BRA	SRCSY		SEARCH SYMBOL TABLE
* ')FNS' COMMAND
FNS	CLR	TEMP		INDICATE LOOKING FOR FUNCTIONS
	LDA	#$C0		PROPER MASK
SRCSY	STA	TEMP+1		SAVE IN LOCATION
	LDA	#$FF		GET END OF TABLE POINTER
	STA	[FREE]		INITIALIZE WORKSPACE
	LDX	#SYMTAB		POINT TO TABLE
FNS1	LDB	,X+		GET LENGTH
	TFR	B,A		SAVE FOR TYPE REFERENCE
	ANDB	#$1F		REMOVE TYPE INFO
	BEQ	FNS4		QUIT IF END
	ANDA	TEMP+1		MASK OFF TYPE INFO
	CMPA	TEMP		DOES IT MATCH?
	BNE	FNS3		NO, SKIP IT
	LDY	FREE		POINT TO WORK SPACE
INW0	PSHS	B,Y		SAVE WRKSPC POINTER
	LDA	,Y		IS THIS THE END?
	CMPA	#$FF		END OF TABLE?
	BEQ	INW2		PUT IT HERE
INW1	LDA	,Y+		GET CHARCTER FROM TABLE
	BEQ	INW3		DON'T PUT IT HERE
	CMPA	B,X		ARE WE OVER
	BLO	INW3		DON'T PUT IT HERE
	BHI	INW2		YES, GO FOR IT
	DECB			BACKUP
	BNE	INW1		KEEP GOING TILL DONE
	BRA	INW2		INSERT IT HERE
INW3	PULS	B,Y		RESTORE
INW5	LDA	,Y+		ADVANCE
	BNE	INW5		TILL WE FIND NEXT
	BRA	INW0		AND TRY AGAIN
INW2	LDA	,Y+		FIND END
	CMPA	#$FF		KEEP LOOKING
	BNE	INW2		NOT HERE
	PULS	B		RESTORE LENGTH
	INCB			ADVANCE FOR ZERO VALUE
INW4	LDA	,Y		GET DATA FROM TABLE
	STA	B,Y		SAVE HIGHER UP
	LEAY	-1,Y		BACKUP FOR LATER
	CMPY	,S		ARE WE BACK YET?
	BHS	INW4		NO, KEEP LOOKING
	PULS	Y		RESTORE POITION
	DECB			CONVERT BACK TO LENGTH
FNS2	LDA	B,X		GET CHARACTER
	STA	,Y+		SAVE IN RAM
	DECB			REDUCE COUNT
	BNE	FNS2		AND KEEP GOING
	CLR	,Y		INDICATE END OF ENTRY
FNS3	LDB	-1,X		GET LENGTH AGAIN
	ANDB	#$1F		REMOVE TYPE INFO
	ADDB	#3		OFFSET TO NEXT
	ABX	B,X		SKIP TO NEXT
	BRA	FNS1		AND TRY AGAIN
FNS4	LDX	FREE		POINT TO WORKSPACE
FNS5	CLRB			SET PRINT POSITION TO ZERO
FNS6	LDA	,X+		GET DATA FROM WORKSPACE
	BEQ	FNS7		ADVANCE TO NEXT
	CMPA	#$FF		END OF TABLE?
	BEQ	FNS8		IF SO, STOP
	LBSR	PUTCHR		DISPLAY
	INCB			INDICATE WE ADVANCED
	BRA	FNS6		AND CONTINUE
FNS7	LBSR	SPACE		DISPLAY A SPACE
	INCB			ADVANCE
	BITB	#$07		TEST FOR AT A TAB STOP
	BNE	FNS7		NO, KEEP GOING
	CMPB	#60		ARE WE OVER LIMIT?
	BLO	FNS6		NO, WE ARE OK
	LBSR	LFCR		NEW LINE
	BRA	FNS5		AND TRY AGAIN
FNS8	TSTB			ARE WE AT BEGINNING OF LINE?
	BEQ	NOLF		NO NEED TO NEW LINE
	LBSR	LFCR		NEW LINE
NOLF	RTS
* ')SYSTEM' COMMAND
SYSTEM	PSHS	Y		SAVE COMMAND
	CLRA
	SSR	104		ENABLE DOS MESSAGES
	PULS	Y		RESTORE COMMAND
	LBSR	SKP		CHECK FOR OPERAND
	BEQ	DOSENT		EXECUTE DOS COMMAND
	SSR	100		EXECUTE COMMAND
	BRA	SYST1		AND QUIT
DOSENT	SSR	101		ENTER DOS
SYST1	CLRA			DISABLE MESSAGES
	SSR	105		WITH DOS COMMAND
	RTS
* ')LIB' COMMAND
LIB	LBSR	SKP		LOOK FOR NAME
	BNE	LIB1		DON'T ASSUME DEFAULT
	LDY	#DEFNAM		POINT TO DEFAULT NAME
	BRA	LIB2		AND DISPLAY IT
LIB1	LBSR	FILNAM		GET FILENAME
LIB2	SSR	9		GET FILENAME
	LBNE	UNCMD		ERROR, QUIT
	SSR	94		DISPLAY DIRECTORY
	BEQ	LIB3		OK
	LBSR	SYSMSG		DISPLAY MESSAGE
	FCCZ	'LIBRARY EMPTY'
LIB3	RTS
* ')WSID' COMMAND
WSID	LBSR	SKP		LOOK FOR OPERAND
	BEQ	WSID1		IF NONE, SHOW IT
	LBSR	FILNAM		GET FILENAME
	SSR	10		GET FROM OS
	LBNE	UNCMD		FAILED
	LEAY	8,X		SKIP TO NAME FIELD
	LBSR	DSPSTR		DISPLAY MESSAGE
	FCCZ	'WAS '
	BSR	DWSID		DISPLAY WHAT IT WAS
WSISET	LDB	#8		MOVE EIGHT CHARACTERS
	LDX	#ID		POINT TO ID
WSID3	LDA	,Y+		GET CHAR
	STA	,X+		SAVE ID
	DECB			REDUCE COUNT
	BNE	WSID3		AND SAVE IT ALL
WSID2	RTS
WSID1	LBSR	DSPSTR		DISPLAY MESSAGE
	FCCZ	'IS '
* DISPLAY WORKSPACE ID
DWSID	LDX	#ID		POINT TO ID
	LDB	#8		MAX EIGHT CHARACTERS
WSID4	LDA	,X+		GET CHAR
	BEQ	WSID5		QUIT
	LBSR	PUTCHR		OUTPUT
	DECB			REDUCE COUNT
	BNE	WSID4		AND CONTINUE
WSID5	LBSR	LFCR		NEW LINE
	RTS
NOTSI	LBSR	SYSMSG		DISPLAY MESSAGE
	FCCZ	'NOT WITH SI'
	RTS
* ')SAVE' COMMAND
SAVE	LBSR	SKP		LOOK FOR PARAMETER
	BNE	SAV1		USER SUPPLIED FILENAME
	LDX	#ID		POINT TO SAVED ID
	LDB	#8		MAX EIGHT CHARACTERS
	LDY	#CID		POINT TO CID
SAV6	LDA	,X+		GET CHARACTER FROM ID
	CMPA	,Y+		IS IT SAME AS CLEAR
	BNE	SAV7		NO, IT'S OK
	DECB			REDUCE COUNT
	BNE	SAV6		KEEP LOOKING
	LBRA	CLMSG		GET UPSET
SAV7	LDX	#ID		POINT TO ID
	LDB	#8		MOVE EIGHT CHARACTERS
	LDY	#RAM		POINT TO INPUT BUFFER
	PSHS	Y		SAVE POINTER
SAV3	LDA	,X+		GET CHAR
	BEQ	SAV4		END, GO AGAIN
	STA	,Y+		SAVE IN OUTPUT
	DECB			REDUCE COUNT
	BNE	SAV3		AND KEEP GOING
SAV4	LDA	#$0D		GET CR
	STA	,Y		SAVE IN FILENAME
	PULS	Y		RESTORE POINTER
SAV1	LBSR	FILNAM		GET FILENAME
SAV5	LDD	SAVSTK		GET SAVED STACK
	CMPD	#STACK		DO WE HAVE SI?
	BNE	NOTSI		NOT WITH SI
	SSR	10		TELL DOS
	LBNE	UNCMD		IF BAD, SKIP IT
	LEAY	8,X		POINT TO FILENAME
	LBSR	WSISET		SET ID
	LDD	FREE		GET FIRST FREE ADDRESS
	SUBD	#FREE		AND CALCULATE OFFSET
	TFR	D,X		COPY TO X FOR DIVIDE
	LDD	#512		SIZE OF DISK SECTORS
	LBSR	DIV		PERFORM DIVISION
	CMPD	#0		ANY REMAINDER
	BEQ	SAV2		NO INC
	LEAX	1,X		ADVANCE FOR REMAINDER OF SECTOR
SAV2	TFR	X,D		COPY SIZE TO D
	LDX	#FREE		POINT TO START OF WS
	SSR	54		SAVE FILE OUT
	LBNE	SYSERR		INDICATE SYSTEM ERROR
	RTS
* ')ERASE' COMMAND
ERASE	LBSR	SFSYM		LOOK FOR SYMBOLS
	LBEQ	UNCMD		INVALID COMMAND
	STY	TEMP		SAVE FOR LATER
	LBSR	DOREST		PERFORM RESET
	LDY	TEMP		AND GET POINTER BACK
	LEAY	-1,Y		BACKUP TO SYMBOL
	LBSR	LOOKUP		LOOK FOR SYMBOL
	BNE	NOTFNS		DOES NOT EXIST
	BSR	ERASYM		ERASE IT
	BRA	NOTF1
NOTFNS	LBSR	SYSMSG		DISPLAY MESSAGE
	FCCZ	'NOT FOUND'
NOTF1	LBRA	CMD		GO HOME
*
* ERASES SYMBOL TABLE ENTRY POINTED TO BY "X" REGISTER
*
* DETERMINE TYPE OF SYMBOL
ERASYM	PSHS	X		SAVE POINTER TO SYMBOL
	LDA	,X		GET TYPE/LENGTH
	TFR	A,B		COPY
	ANDA	#$E0		MASK OFF LENGTH
	ANDB	#$1F		MASK OFF TYPE
	ADDB	#2		ADVANCE PAST TYPE/LENGTH, NEST
	ABX			ADVANCE PAST NAME
	LDY	,X++		GET LENGTH
	STY	TEMP1		SAVE ADDRESS
	CLR	TEMP2		SET ZERO OFFSET
	CLR	TEMP2+1		SET ZERO OFFSET
	CMPA	#$60		IS IT LABEL TYPE SYMBOL?
	BEQ	RMSYM		IF SO, IT'S A SPECIAL CASE
* DETERMINE SIZE OF SYMBOL
ERANXT	LDY	FREE		USE FREE FOR OFFSET
	LDB	,X		GET TYPE/LENGTH
	TFR	B,A		COPY
	ANDA	#$E0		MASK OFF LENGTH
	ANDB	#$1F		MASK OFF TYPE
	BEQ	FREOFF		END OF TABLE, REMOVE IT
	ADDB	#2		ADVANCE PAST TYPE/LENGTH, NEST BYTES
	ABX			SKIP NAME AS WELL
	LDY	,X++		GET ADDRESS
	CMPA	#$60		IS IT LABEL TYPE SYMBOL?
	BEQ	ERANXT		IF SO, CONTINUE LOOKING
FREOFF	TFR	Y,D		GET ADDRESS
	SUBD	TEMP1		CONVERT TO OFFSET
	STD	TEMP2		SAVE OFFSET
* REMOVE SYMBOL TABLE ENTRY, AND ADJUST ADDRESSES
RMSYM	PULS	X		RESTORE POINTER TO SYMBOL
	LDB	,X		GET LENGTH
	ANDB	#$1F		MASK OFF LENGTH
	ADDB	#4		OFFSET TO NEXT
	LEAY	B,X		POINT TO NEXT SYMBOL
RMS1	LDB	,Y+		GET CHAR FROM SYMBOL
	STB	,X+		SAVE
	TFR	B,A		COPY
	ANDA	#$E0		MASK LENGTH
	ANDB	#$1F		CALCULATE LENGTH
	BEQ	RMS2		IF END, QUIT
	ADDB	#3		OFFSET FOR NEXT
	PSHS	A		SAVE SYMBOL TYPE
RMS11	LDA	,Y+		GET BYTE
	STA	,X+		SAVE
	DECB			REDUCE COUNT
	BNE	RMS11		CONTINUE COPYING
	PULS	A		RESTORE TYPE
	CMPA	#$60		LABEL TYPE?
	BEQ	RMS1		IF SO, FORGET IT
	LDD	-2,X		GET ADRESS
	SUBD	TEMP2		SUBTRACT OFFSET
	STD	-2,X		RESAVE
	BRA	RMS1		AND CONTINUE
* MOVE MEMORY BACK REQUIRED AMOUNT
RMS2	LDD	TEMP2		GET OFFSET
	BEQ	NOMOVE		DON'T MOVE IF NO OFFSET
	LDY	TEMP1		GET SYMBOL ADDRESS
	LEAX	D,Y		POINT TO NEW LOCATION
	CMPX	FREE		SPACIAL CASE FOR LAST VARIABLE IN TABLE
	BHS	SAVFRE		IF SO, SAVE IT
RMS3	LDA	,X+		GET FROM MEMORY
	STA	,Y+		SAVE IN OLD LOCATION
	CMPX	FREE		ARE WE OVER
	BLO	RMS3		GO FOR IT
SAVFRE	STY	FREE		RESAVE
NOMOVE	RTS
* ')SI' COMMAND
SI	LDX	NAMPTR		POINT TO NAME
	LDD	LINCT		GET LINE COUNTER
	LDY	SAVSTK		POINT TO SAVED STACK POINTER
	CMPY	#STACK		AT TOP?
	BEQ	NOSUSP		NONE
SI1	LBSR	DSPNAM		DISPLAY
	LDX	,Y		GET POINTER TO LOCAL VARIABLE LIST
	LBSR	OULI		DISPLAY VARIABLES
	LDX	10,Y		POINT TO NAME
	LDD	8,Y		GET LINE NUMBER
	LDY	2,Y		GET NEXT SAVED STACK POINTER
	CMPY	#STACK		ARE WE AT TOP?
	BNE	SI1		CONTINUE
	RTS
* ')REL' RELEASE ONE SUSPENDED FUNCTION
RELEAS	LDY	SAVSTK		GET STACK POINTER
	CMPY	#STACK		AT TOP?
	BEQ	NOSUSP		INDICATE NOTHING TO BE EXCITED ABOUT
REL1	PULS	A,B		GET PROGRAM COUNTER
	STD	16,Y		SET RETURN ADDRESS
	TFR	Y,S		COPY IT OVER
	LBRA	EFUNC		AND DO IT
NOSUSP	LBSR	SYSMSG		DISPLAY MESSAGE
	FCCZ	'NO SI IN WS'
	RTS
* PERFORM A RESET
DOREST	PULS	A,B		GET PC
	STD	TEMP4		SAVE VALUE
DORES1	LDY	SAVSTK		CKECK FOR STACK EMPTY
	CMPY	#STACK		ARE WE AT TOP?
	BEQ	CLALL		IF SO, CLEAR IT
	BSR	REL1		RELEASE THIS BUNCH
	BRA	DORES1		AND CONTINUE
CLALL	LDD	#HIRAM		TOP OF RAM
	STD	RAMTOP		SET UP RAM TOP
	LDD	#IOTA0		POINT TO NULL VECTOR
	STD	PARM		SET UP PARAMETER VALUE
	CLR	LEVEL		SET LEVEL ZERO
	JMP	[TEMP4]		RETURN TO CALLER
* ')STATUS' COMMAND
STATUS	LBSR	DSPSTR		DISPLAY STRING
	FCCZ	'WORKSPACE NAME: '
	LBSR	DWSID		DISPLAY IT
	LBSR	DSPSTR		DISPLAY STRING
	FCCZ	'SYMBOLS IN USE: '
	LDY	#$0		INDICATE ZERO SYMBOLS
	LDX	#SYMTAB		POINT TO START OF TABLE
STSYM	LDB	,X+		GET STARTING VALUE
	ANDB	#$1F		MASK TYPE BITS
	BEQ	STSY1		END OF TABLE
	LEAY	1,Y		THIS IS ONE
	ADDB	#3		OFFSET FOR SYMBOL TABLE ENTRIES
	ABX			ADVANCE
	BRA	STSYM		CONTINUE LOOKING
STSY1	TFR	Y,D		COPY TO D
	LBSR	DECOUT		DISPLAY IT
	PSHS	X		SAVE X
	LBSR	DSPSTR		DISPLAY STRING
	FCB	$0D
	FCCZ	'SYMBOL TABLE SIZE: '
	LDD	FREMEM		POINT TO END OF SYMBOL TABLE
	SUBD	#SYMTAB+1	CONVERT TO SIMPLE OFFSET
	LBSR	DECOUT		DISPLAY IT
	LBSR	DSPSTR		DISPLAY STRING
	FCB	$0D
	FCCZ	'SYMBOL TABLE FREE: '
	LDD	FREMEM		GET FREE MEMORY SPACE
	SUBD	,S++		CONVERT TO BINARY VALUE
	LBSR	DECOUT		DISPLAY
	LBSR	DSPSTR		DISPLAY STRING
	FCB	$0D
	FCCZ	'WORKSPACE REMAINING: '
	LDD	RAMTOP		POINT TO TOP OF RAM
	SUBD	FREE		CONVERT TO FREE SPACE
	LBSR	DECOUT		DISPLAY
	LBRA	LFCR		NEW LINE
* UNKNOWN SYSTEM COMMAND
UNCMD	LBSR	SYSMSG
	FCCZ	'INCORRECT COMMAND'
	RTS
* SYSTEM ERROR HAS OCCURED
SYSERR	PSHS	A,B,X,Y
	LBSR	SYSMSG
	FCCZ	'SYSTEM ERROR'
	PULS	A,B
	SSR	27
	SSR	21
	PULS	A,B
	SSR	27
	SSR	21
	PULS	A,B
	SSR	27
	SSR	21
	PULS	A,B
	SSR	27
	SSR	21
	PULS	A,B
	SSR	27
	SSR	21
	TFR	S,D
	SSR	27
	SSR	21
	TFR	U,D
	SSR	27
	SSR	22
	LBRA	CMD
*
* SYSTEM COMMAND TEXT TABLE
*
CMDTAB	FCC	'OF'
	FCB	'F'+$80
	FDB	OFF
	FCC	'CLEA'
	FCB	'R'+$80
	FDB	CLEAR
	FCC	'FN'
	FCB	'S'+$80
	FDB	FNS
	FCC	'VAR'
	FCB	'S'+$80
	FDB	VARS
	FCC	'LBL'
	FCB	'S'+$80
	FDB	LBLS
	FCC	'SY'
	FCB	'S'+$80
	FDB	SYSTEM
	FCC	'LI'
	FCB	'B'+$80
	FDB	LIB
	FCC	'WSI'
	FCB	'D'+$80
	FDB	WSID
	FCC	'SAV'
	FCB	'E'+$80
	FDB	SAVE
	FCC	'LOA'
	FCB	'D'+$80
	FDB	LOAD
	FCC	'DRO'
	FCB	'P'+$80
	FDB	DROP
	FCC	'ERAS'
	FCB	'E'+$80
	FDB	ERASE
	FCC	'S'
	FCB	'I'+$80
	FDB	SI
	FCC	'RE'
	FCB	'L'+$80
	FDB	RELEAS
	FCC	'RESE'
	FCB	'T'+$80
	FDB	RESET
	FCC	'CONTINU'
	FCB	'E'+$80
	FDB	CONCMD
	FCC	'STA'
	FCB	'T'+$80
	FDB	STATUS
	FCB	$80
	FDB	UNCMD
* DEFAULT VECTOR STRING, EMPTY NUMERIC VECTOR
IOTA0	FCB	$01		TYPE = NUMERIC
	FDB	0		LENGTH = ZERO
*
* STRINGS
*
DEFNAM	FCC	'*.APL'
	FCB	$0D
	FCC	'e@LX'
	FCB	$0D
LXNAME	EQU	*-2
CONTIN	FCCZ	'CONTINUE.APL'
*
* STANDARD OPERATING SYSTEM INTERFACE, SUPPORTS
* OPERATING SYSTEM COMMANDS, AND FILE I/O
* ON ENTRY, 'X' POINT TO LEFT OPERAND, 'Y' POINTS TO RIGHT OPERAND
*
* FUNCTIONS:
*   0 - EXECUTE DOS COMMAND
*   1 - OPEN FILE/READ
*   2 - OPEN FILE/WRITE
*   3 - TEST FOR FILE EXISTANCE
*   4 - READ MEMORY (ADDR, ADDR, ADDR ...)
*   5 - WRITE MEMORY (ADDR, DATA, DATA ...)
*   6 - EXECUTE SSR (IN=SSR,AB,X,Y,U - OUT=RC,AB,X,Y,U)
*   <file>o<char>   - Write file
*   <file>o0	    - Read file
*   <file>o1	    - Close file
*   <file>o2	    - Rewind file
*
OSFUNC	LDA	,X		GET TYPE
	DECA			INTEGER
	LBNE	CDOM		ERROR
	LDD	1,X		GET LENGTH
	CMPD	#261		SPECIAL FILE STUFF?
	LBEQ	OSFILE		ITS A FILE ACCESS
* NON FILE ACCESS
OSFNF	CMPD	#1		FUNCTION CODE
	LBNE	CLEN		OUT OF RAMGE
	LDD	3,X		GET VALUE
	TSTA			HIGH ZERO?
	LBNE	CDOM		ERROR
* CHECK FOR EXECUTE OPERATING SYSTEM COMMAND
	TSTB
	BNE	OSOPEN		NO, TRY OPEN
	LBSR	OSROT		ROTATE IT
	LDA	#$0D		GET CR, TERMINATE COMMAND
	STA	,U		SAVE IT
	LEAY	3,Y		POINT TO COMMAND
	SSR	100		EXECUTE
OSAVRC	BEQ	OSRCZ		RC IS ZERO
	TFR	A,B		COPY TO B
	BRA	OSRC1		RETURN RC
OSRCZ	CLRB			SET ZERO RC
OSRC1	CLRA			CLEAR HIGH BYTE
OSRES	LDX	2,S		GET POINTER BACK
	STD	3,X		SAVE VALUE
	LDB	#1		GET TYPE AND LENGTH
	STB	,X		SAVE IT
	STD	1,X		SAVE LENGTH
	RTS
* OPEN FILE FOR READ
OSOPEN	DECB			TEST FOR OPEN READ
	BNE	OSOPW		NO, TRY FOR OPEN WRITE
	LBSR	OSROT		SWAP IT
	CLR	,U		INDICATE END
	LEAY	3,Y		PT TO TEXT
	SSR	10		GET IT
	BNE	OSAVRC		INVALID
	LDU	2,S		PT TO OPERAND
	LDD	#261		LENGTH
	STA	,U+		SAVE TYPE
	STD	,U++		SAVE LENGTH
	SSR	55		OPEN FOR READ
	BNE	OSAVRC		INDICATE OK
	RTS
* OPEN FILE FOR OUTPUT
OSOPW	DECB			OPEN FOR WRITE?
	BNE	OSTFIL		NO, TRY CLOSE
	LBSR	OSROT		SWAP IT
	CLR	,U		SET TERMINATOR
	LEAY	3,Y		DO IT
	SSR	10		OK?
	BNE	OSAVRC		NO, GET UPSET
	LDU	2,S		PT TO OPERAND
	LDD	#261		SIZE OPERAND
	STA	,U+		SET TYPE
	STD	,U++		SAVE LENGTH
	SSR	56		OPEN FILE FOR WRITE
	BNE	OSAVRC		SAVE RC
OSRM2	RTS
* TEST FOR FILE EXISTANCE
OSTFIL	DECB			TEST FOR FILE?
	BNE	OSRMEM		NO, TRY NEXT
	LBSR	OSROT		ROTATE OPERAND
	CLR	,U		SET DELIMITER
	LEAY	3,Y		ADVANCE
	SSR	10		GET FILENAME
	BNE	OSAVRC		BAD, QUIT
	SSR	68		LOOK FOR IT
	BRA	OSAVRC		SAVE RC
* READ MEMORY
OSRMEM	LDA	,Y		INTEGER DATA ONLY
	CMPA	#1		INTEGER?
	LBNE	CDOM		ERROR, WRONG TYPE
	DECB			READ MEMORY?
	BNE	OSWMEM		WRITE MEMORY
	LDD	1,Y		GET LENGTH
	PSHS	A,B		SAVE PTR
	LEAY	3,Y		ADVANCE TO DATA
OSRM1	LDD	,S++		GET COUNT
	BEQ	OSRM2		EXIT
	SUBD	#1		REDUCE COUNT
	STD	,--S		RESAVE
	LDX	,Y		GET ADDRESS
	LDB	,X		GET DATA
	CLRA			ZERO HIGH
	STD	,Y++		SET VALUE
	BRA	OSRM1		AND CONTINUE
* WRITE MEMORY
OSWMEM	DECB			WRITE MEMORY?
	BNE	OSSSR		NO, TRY OSR
	LDD	1,Y		GET LENGTH
	LBEQ	CLEN		ZERO LENGTH INVALID
	SUBD	#1		CONVERT
	STD	1,Y		SET LENGTH TO L-1
	PSHS	A,B		SAVE REGS
	ROLB			X2
	LSLA			FOR INTEGER ENTRIES
	LEAY	3,Y		ADVANCE TO DATA
	LEAY	D,Y		POINT TO DATA
	LDX	,Y		GET ADDRESS
OSWM1	LDD	,S++		GET COUNT
	BEQ	OSRM2		END, EXIT
	SUBD	#1		REDUCE LENGTH
	STD	,--S		RESAVE
	LDD	,--Y		GET DATA TO WRITE
	LDA	,X		GET OLD DATA
	STB	,X+		WRITE NEW DATA
	EXG	A,B		SWAP
	CLRA			ZERO HIGH
	STD	,Y		AND REWRITE
	BRA	OSWM1		CONTINUE
* PERFORM A DOS SYSTEM REQUEST
OSSSR	DECB			IS THIS IT?
	LBNE	CDOM		NO, EXIT
	LDD	1,Y		GET LENGTH
	CMPD	#5		FOUR ELEMENTS?
	LBNE	CLEN		LENGTH ERROR
	LDD	11,Y		GET SSR NUMBER
	STB	OSSRNO+1	SET IT
	LDD	9,Y		GET A,B
	LDX	7,Y		GET X
	LDU	3,Y		GET 'U'
	LDY	5,Y		GET 'Y'
OSSRNO	SSR	0		SYSTEM REQUEST
	PSHS	CC,X		SAVE REGS
	LDX	5,S		GET PTR TO DATA
	STU	3,X		SAVE 'U'
	STY	5,X		SAVE 'Y'
	STD	9,X		SAVE 'A'+'B'
	TFR	A,B		B = RC
	PULS	CC,Y		RESTORE REGS
	BNE	OSSR1		NON-ZERO
	CLRB
OSSR1	CLRA			ZERO HIGH
	STD	11,X		SET RC
	STY	7,X		SET 'X' VALUE
	RTS
* ACCESSING A FILE
OSFILE	LEAU	3,X		SET UP FILE PTR
	LDA	,Y+		TEST TYPE
	BNE	OSFFUN		FILE FUNCTIONS
* WRITE FILE
	LDX	,Y+		GET LENGTH
	BEQ	OSWR2		NULL LINE
OSWR1	TFR	X,D		COPY IT
	LDA	D,Y		GET CHARACTER
	SSR	61		WRITE CHAR
	BNE	OSAVR2		ERROR, RETURN CODE
	LEAX	-1,X		REDUCE COUNT
	BNE	OSWR1		AND CONTINUE
OSWR2	LDA	#$0D		CR
	SSR	61		WRITE CHARACTER
	BRA	OSAVR2		AND EXIT
* OTHER FILE FUNCTIONS
OSFFUN	LDD	,Y++		GET LENGTH
	CMPD	#1		PROPER?
	LBNE	CLEN		NO
	LDD	,Y		GET VALUE
	TSTA
	LBNE	CDOM		OUT OF RAMGE
* READ DATA FILE FILE
	TSTB			ZERO?
	BNE	OSFCLO		CLOSE FILE
	CLR	-3,Y		INDICATE CHARACTER
	LDX	#-1		START WITH -1
OSRE1	SSR	59		READ CHARACTER FROM FILE
	BNE	OSAVR2		ERROR
	STA	,Y+		SAVE IN DATA AREA
	LEAX	1,X		INCREASE LENGTH
	CMPA	#$0D		CR?
	BNE	OSRE1		CONTINUE
	LDY	2,S		GET PTR BACK
	STX	1,Y		SET LENGTH
* ROTATE OPERAND VALUE(Y)
OSROT	PSHS	Y		SAVE REGISTERS
	TST	,Y		WHAT FORM ARE WE
	LBNE	CDOM		REVERSING CHARACTER ARRAY
	LDD	1,Y		GET LENGTH
	BEQ	OSREND		NOTHING TO DO
	LEAX	3,Y		GET START OF VECTOR
	LEAY	D,X		SKIP TO END
	TFR	Y,U		COPY IT
OSREV	LDA	,-Y		GET CHARACTER
	LDB	,X+		AND GET OTHER CHARACTER
	PSHS	X		SAVE POSITION
	CMPY	,S++		ARE WE THERE?
	BLO	OSREND		IF SO, EXIT
	STB	,Y		SET NEW VALUE
	STA	-1,X		AND NEW VALUE HERE
	BRA	OSREV		CONTINUE REVERSING
OSREND	PULS	Y,PC		RESTORE REGISTERS
* CLOSE FILE
OSFCLO	DECB
	BNE	OSFREW		TRY REWIND
	SSR	57		CLOSE FILE
OSAVR2	LBRA	OSAVRC		AND RETURN
* REWIND FILE
OSFREW	DECB
	LBNE	CDOM		NOT REWIND, EXIT
	SSR	62		REWIND FILE
	BRA	OSAVR2		RETURN CODE
